<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>操作系统：进程和线程介绍</title>
      <link href="/2019/11/23/os-process-thread/"/>
      <url>/2019/11/23/os-process-thread/</url>
      
        <content type="html"><![CDATA[<h2 id="基础知识介绍"><a href="#基础知识介绍" class="headerlink" title="基础知识介绍"></a>基础知识介绍</h2><p>“操作系统是什么”这个问题的答案我相信现在玩过电脑的同学应该都知道是什么，但是如果说到“操作系统”内部的一些机制可能就会有些言语不清了吧！<br>我也是这学期开始学习这门课程的，所以请大家跟着我一起梳理操作系统中的重要知识点。</p><p>先说明一点，关于操作系统的历史和分类我感觉还是交给你自己百度吧，我这篇文章将跳过所有历史和分类。如果实在需要一些历史说明我会找一个小空间加上去的。</p><p>我所认为的操作系统核心知识（不服忍着）：</p><ul><li>进程管理</li><li>内存管理</li><li>存储管理</li><li>设备管理</li></ul><h3 id="什么是程序"><a href="#什么是程序" class="headerlink" title="什么是程序"></a>什么是程序</h3><p>对于CPU来说，它只能识别二进制位，而这些二进制位根据不同的环境可以被解释成不同的意义。<code>程序</code>就是一些可以让CPU看懂的二进制位组成（这些位就是所写的代码经过编译后形成的）。但是代码中有一些是<code>指令</code>，还有的是<code>数据</code>，这对CPU来说是不能区分，这就需要操作系统帮CPU指出哪些是指令，哪些是数据，即操作系统把程序的二进制位按照规定的格式加载到内存中。操作系统的这一点“私心”，即只想执行符合它所规定格式的二进制，所以程序就被分成了<code>Windows程序</code>(Windows PE/COFF格式)和<code>Linux程序</code>(ELF格式)等类型。但是总的来说，程序就是 <code>CPU所支持的指令</code> + <code>程序运行所需的数据</code>。从这里我们也就知道了，程序是<code>静态的</code>，无论操作系统把不把它复制进内存，它都在硬盘里面，直到把它删除。</p><h3 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h3><p>进程，又叫做任务，是操作系统对CPU运行的指令和数据集的一种抽象。如果把程序当作一种类型，则加载进内存即是使用该类型创建对象。使用Java的面向对象来说，类是不可变的（静态数据除外），但是类的对象确实可以改变的。</p><p>进程和程序的区别：</p><ul><li>程序是静态的，存放在硬盘上，可以被操作系统读取。</li><li>进程是程序加载到内存后的名称，是让CPU读取执行的。</li><li>进程是动态的。</li></ul><h3 id="进程在内存中的表示形式"><a href="#进程在内存中的表示形式" class="headerlink" title="进程在内存中的表示形式"></a>进程在内存中的表示形式</h3><p>操作系统为了方便管理进程运行时的数据，所以要使用一个数据结构记录进程运行时的环境状态。这个数据结构称为<code>进程控制块</code>(PCB),它是由操作系统创建和管理。<br>PCB结构中包含着数据有：</p><ul><li>标识符：操作系统为了区分进程，给每一个进程分配的id</li><li>状态：进程的运行状态</li><li>优先级：被CPU执行的优先度</li><li>程序计数器：即将被CPU执行的下一条指令地址</li><li>内存指针：程序被加载到内存后的指令和数据的相关指针</li><li>上下文数据：进程在被CPU执行过程中寄存器的数据</li><li>I/O状态信息：被进程所使用的I/O请求记录</li><li>记账信息：进程运行产生的一些统计数据，比如处理器时间总和，使用的时钟数总和等。</li></ul><h2 id="进程的状态和状态转换概念"><a href="#进程的状态和状态转换概念" class="headerlink" title="进程的状态和状态转换概念"></a>进程的状态和状态转换概念</h2><h3 id="三状态模型"><a href="#三状态模型" class="headerlink" title="三状态模型"></a>三状态模型</h3><p><img src="three_model.png" alt="三状态模型图"></p><ul><li>就绪态：操作系统已经加载程序进入内存，并且创建好PCB块，等待CPU执行</li><li>运行态：正在被CPU进行执行</li><li>等待态：由于某些事件（比如等待IO）而不能继续执行的。</li></ul><p>转换事件：</p><ul><li><code>就绪 -&gt; 运行</code>: 由调度程序选择的进程由就绪状态转为被CPU执行的运行态</li><li><code>运行 -&gt; 就绪</code>: 由于进程自愿放弃CPU，或者更高优先级的进程抢占了CPU，又或者进程运行到系统所设置的时间段等。</li><li><code>运行 -&gt; 等待</code>: 由于进程等待某些事件的发生而进入</li><li><code>等待 -&gt; 就绪</code>: 进程等待的事件发生后转入</li></ul><h3 id="五状态模型"><a href="#五状态模型" class="headerlink" title="五状态模型"></a>五状态模型</h3><p><img src="five_model.png" alt="五状态模型图"></p><ul><li>运行态：该进程正在被CPU执行</li><li>就绪态：进程做好了准备，只要有机会就开始执行</li><li>阻塞/等待态：进程在某些事件发生前不能执行</li><li>新建态：刚刚创建的进程，操作系统还没有把它加入可执行进程组中。通常是PCB已经创建好但是还没有加载到内存中的新进程</li><li>退出态：操作系统从可执行组中释放出的进程，或者因为自身停止，或被取消执行</li></ul><p>转换事件：</p><ul><li><code>空 -&gt; 新建</code>：创建执行一个程序的新进程</li><li><code>新建 -&gt; 就绪</code>：操作系统准备好再接纳一个进程时，把一个进程从新建态转为就绪态</li><li><code>就绪 -&gt; 运行</code>：需要一个新进程执行时，有调度器或分派器从就绪态中选择一个执行</li><li><code>运行 -&gt; 退出</code>：当前正在执行的进程表示自己执行完成或者取消</li><li><code>运行 -&gt; 就绪</code>：由于进程自愿放弃CPU，或者更高优先级的进程抢占了CPU，又或者进程运行到系统所设置的时间段等。</li><li><code>运行 -&gt; 阻塞</code>：由于进程等待某些事件的发生而进入</li><li><code>阻塞 -&gt; 就绪</code>：进程等待的事件发生后转入</li><li><code>就绪 -&gt; 退出</code>：这种通常时允许父进程终止子进程的操作系统中可见</li><li><code>阻塞 -&gt; 退出</code>：同上</li></ul><h3 id="七状态模型"><a href="#七状态模型" class="headerlink" title="七状态模型"></a>七状态模型</h3><p><img src="seven_model.png" alt="七状态模型图"></p><ul><li>阻塞/挂起态：进程在外存中并等待一个事件</li><li>就绪/挂起态：进程在外村中，但是只要被载入内存就可以执行</li></ul><p>一些重要的转换事件：</p><ul><li><code>阻塞 -&gt; 阻塞/挂起</code>：如果没有就绪进程，则至少一个阻塞进程被换出（换出到外存中），为另一个没有阻塞的进程让出空间。</li><li><code>阻塞/挂起 -&gt; 就绪/挂起</code>：如果等待的事件发生了，则处于阻塞/挂起状态的进程可以转换到就绪/挂起状态。</li><li><code>就绪/挂起 -&gt; 就绪</code>：如果内存中没有就绪态进程，操作系统需要调入一个进程继续执行</li><li><code>就绪 -&gt; 就绪/挂起</code>：如果释放内存以得到足够的内存空间的唯一方式就是挂起一个就绪态的进程，那么这种转换才会方式。但是通常就绪态更多的是可以直接运行。</li><li><code>新建 -&gt; 就绪/挂起或者新建 -&gt; 就绪</code>：当创建一个进程时，该进程被加入到就绪队列或者加入到就绪/挂起队列中。</li><li><code>阻塞/挂起 -&gt; 阻塞</code>：这种转换比较少见，作为特殊情况下才会出现（和进程调度算法有关）</li></ul><blockquote><p>挂起的用途：这种是由于内存空间不足，由调度算法执行，使一些进程换出到硬盘上。<br>一个挂起的进程，无论是否等待一个事件都不能立即执行</p></blockquote><p>导致进程挂起的原因：</p><ul><li>交换</li><li>其他OS原因</li><li>交互式用户请求</li><li>定时</li><li>父进程请求</li></ul><h2 id="进程的管理"><a href="#进程的管理" class="headerlink" title="进程的管理"></a>进程的管理</h2><p>操作系统的重要功能之一就是管理进程，即对进程的创建、销毁和运行状态进程管理。</p><h3 id="进程的执行模式"><a href="#进程的执行模式" class="headerlink" title="进程的执行模式"></a>进程的执行模式</h3><p>操作系统作为一种中间层软件—对下管理硬件资源，对上为应用程序提供通用接口服务，故应用层软件对硬件资源的合理使用都是由操作系统保证的。CPU对其提供了至少两种执行模式。<br>即对操作系统的执行提供一种叫做<code>特权态</code>或<code>内核态</code>的模式，对用户引用程序提供<code>用户态</code>模式。CPU针对不同模式下执行不同的控制能力。在内核态下，软件具有对CPU以及所有指令，寄存器和内存的控制能力，但是这些对用户态下的软件时不需要的，并且为了安全性也不会提供给用户态下的应用程序。</p><p>那么怎么切换这两种模式呢？在典型情况下，都是由用户程序通过一些系统提供的<code>系统调用</code>或者<code>中断例程</code>执行时，才会由用户态切换到内核态。<br>例如：在64位IA-64体系结构的Intel Itanium处理器，有一个处理器状态寄存器（PSR），包含2位CPL（当前特权级别）域，级别0是最高特权级别，级别3是最低特权级别。Linux使用级别0最为内核态。<br>当中断发生时，处理器就会清空PSR中的位，包括设置CPL域的值设为0。使用<code>irt</code>（中断返回）指令时，会从处理器恢复中断程序的PSR值，即设为用户态值。</p><h3 id="进程的创建过程"><a href="#进程的创建过程" class="headerlink" title="进程的创建过程"></a>进程的创建过程</h3><p>当操作系统准备创建一个进程时，会按照下面的步骤执行：</p><ol><li>给进程分配一个唯一的进程标识符。</li><li>给进程分配内存空间</li><li>初始化进程控制块（PCB）</li><li>设置正确的连接：目标是把新建的进程放到调度器的数据结构中，方便调度器调度。</li><li>创建或者扩充其他数据结构：比如PCB中的记账数据结构。</li></ol><p>上面的步骤是操作系统创建进程时的要做的事情，但是准确一点来说，作为开发者怎么创建一个进程的呢？或者我们是怎么告诉操作系统要运行一个程序的呢？</p><p>答案就是：由当前正在执行的程序告诉操作系统。就比如，当我们双击桌面上的程序快捷键时，桌面应用程序响应了我们的点击事件，然后知道我们要运行这个程序，然后它就告诉操作系统，我给你个程序，用户想运行它，然后操作系统就按照上面的流程<br>为它创建一个进程。这是不是类似于父子关心呢？我们双击的那个程序运行后的进程就是桌面这个进程的孩子。其实现在的操作系统创建进程就是通过父进程创建子进程的方式新建进程，子进程也可以创建其他进程，这样就形成了一个<code>进程树</code>。<br>到了这里你可能会想到操作系统的第一个进程是谁，又是谁创建的呢？这个可以看一下进程上的PID（进程唯一标识）为1的那个就是。Linux上（运行<code>ps -el</code>命令），有一些发行版本是<code>systemd</code>,还有一些发行版本是<code>init</code>。之后所有的进程都是他们创建的（在Linux下<code>任务</code>等同于<code>进程</code>）。作为开发者，本质也是一样的。在Linux上，是使用代码调用系统调用接口<code>fork</code>函数和<code>exec</code>函数。在Windows上，使用<code>CreateProcess</code>函数。</p><p>Windows下CreateProcess函数示例：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;windows.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    STARTUPINFO si<span class="token punctuation">;</span>    PROCESS_INFORMATION pi<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 申请内存 */</span>    <span class="token function">ZeroMemory</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>si<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>si<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    si<span class="token punctuation">.</span>cb <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>si<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ZeroMemory</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pi<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>pi<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 创建子进程 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">CreateProcess</span><span class="token punctuation">(</span>            <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 应用程序名称</span>            <span class="token string">"C:\\WINDOWS\\system32\\mspaint.exe"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 命令，即要运行的程序，这里是打开画板</span>            <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 不继承进程句柄（process handle）</span>            <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 不继承线程句柄（thread handle）</span>            FALSE<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 禁用句柄继承</span>            <span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 不适用创建标志</span>            <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 不使用父进程的已有环境块</span>            <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 不使用父进程的启动目录</span>            <span class="token operator">&amp;</span>si<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 设置新进程的一些特性，比如窗口大小，颜色等</span>            <span class="token operator">&amp;</span>pi <span class="token comment" spellcheck="true">// 创建新进程以及其线程的句柄和标识符</span>            <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Create Process Failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 父进程等待子进程结束</span>    <span class="token function">WaitForSingleObject</span><span class="token punctuation">(</span>pi<span class="token punctuation">.</span>hProcess<span class="token punctuation">,</span> INFINITE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child Complete"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 关闭句柄（释放内存）</span>    <span class="token function">CloseHandle</span><span class="token punctuation">(</span>pi<span class="token punctuation">.</span>hProcess<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">CloseHandle</span><span class="token punctuation">(</span>pi<span class="token punctuation">.</span>hThread<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Linux下的使用：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 存储子进程id</span>    pid_t     pid<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 复制当前进程来创建子进程</span>    pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 创建失败</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span><span class="token string">"Fork Failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果是子进程</span>        <span class="token comment" spellcheck="true">// 子进程执行逻辑</span>         <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child Process Running....\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 使用一个新程序取代自身</span>         <span class="token function">execlp</span><span class="token punctuation">(</span><span class="token string">"/bin/ls"</span><span class="token punctuation">,</span> <span class="token string">"ls"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 父进程逻辑</span>        <span class="token comment" spellcheck="true">// 父进程等待子进程执行完成</span>        <span class="token function">wait</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child Complete.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>fork</code> 和 <code>exec</code>的区别：<br><code>fork</code>是复制当前进程，即执行这个函数后，会出现两个进程，这两个进程一样，不过有一个区别就是，这个函数返回给这两个进程不同的返回值用于区分不同进程。<br><code>fork</code>在父进程中返回值是子进程的PID，在子进程中返回0。<code>sub_pid = fork();</code>这个语句使创建两个进程。后面就可以根据返回值不同区分不同的进程。<br><strong>注意</strong>：<code>fork</code>创建的子进程和父进程具有相同的代码逻辑，如果没有后面的if做区分，则父子进程执行相同的代码，直到运行结束。<br><code>execlp</code>是<code>exec</code>函数系中的一个，<code>exec</code>是加载一个新的程序取代当前程序，如果代码直接执行<code>exec</code>函数，当前程序就会终止，开始执行新的代码。<br>通过<code>fork</code>和<code>exec</code>组合创建新的程序：先使用fork创建一个当前进程的复制进程，然后根据返回值在子进程中运行<code>exec</code>函数执行一个新的进程。<br>例子：比如在Shell中运行一个程序，Shell就会复制自身，然后再让那个程序代替子进程执行。</p></blockquote><h3 id="进程的销毁"><a href="#进程的销毁" class="headerlink" title="进程的销毁"></a>进程的销毁</h3><h3 id="进程的状态切换"><a href="#进程的状态切换" class="headerlink" title="进程的状态切换"></a>进程的状态切换</h3><h2 id="进程之间通信"><a href="#进程之间通信" class="headerlink" title="进程之间通信"></a>进程之间通信</h2><h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><h2 id="线程和进程之间什么关系"><a href="#线程和进程之间什么关系" class="headerlink" title="线程和进程之间什么关系"></a>线程和进程之间什么关系</h2><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2>]]></content>
      
      
      <categories>
          
          <category> 操纵系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操纵系 </tag>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang环境安装</title>
      <link href="/2019/11/22/go-install/"/>
      <url>/2019/11/22/go-install/</url>
      
        <content type="html"><![CDATA[<h2 id="Golang语言介绍"><a href="#Golang语言介绍" class="headerlink" title="Golang语言介绍"></a>Golang语言介绍</h2><p>Golang语言是Google公司开发的一种类C语言，是一门编译型的静态语言，而且Golang语言天生带有高并发功能的语言级别支持。<br>Golang语言类C并不是仅仅在语法上和C语言类似，而且好包含了C的指针特性（优点），可能你有C语言基础的，一看到指针就感觉到可怕，但是Golang的指针只具有C指针的优点，花样也没有C语言多，所以没那么可怕。<br>忘了告诉你了，Golang的语言设计者其中一位就是C语言和Unix系统开发者<code>Ken Thompson</code>大佬。Golang被称为当代的C语言，当然要有现在其他语言所拥有的语言特性：高并发（协程），垃圾回收GC，类型推断和闭包等。<br>当前比较流行的Docker容器技术就是使用Go语言开发的，区块链技术实现也可以使用Go语言。Go有这么多优点，还不学吗？</p><h2 id="Golang语言环境安装"><a href="#Golang语言环境安装" class="headerlink" title="Golang语言环境安装"></a>Golang语言环境安装</h2><h3 id="1-Golang环境下载"><a href="#1-Golang环境下载" class="headerlink" title="1. Golang环境下载"></a>1. Golang环境下载</h3><p>第一步肯定是下载Golang的安装包啦！但是，由于某些原因，我们是无法访问Google服务器，但是国内有一些大佬已经在国内做了代理，可以通过国内代理下载：</p><ul><li><p>国内Golang下载：<code>https://studygolang.com/dl</code></p></li><li><p>官方Golang下载：<code>https://golang.org/dl/</code></p><p>  点击网址，我们可以看到一些下载选项：<br>  <img src="download1.png" alt="国内下载"></p></li></ul><p>我们根据自己电脑的操作系统选择不同的下载包下载即可。不过可以看到windows和MacOS 都支持两种下载方式，一种是<code>zip</code>包方式下载，另一种就是推荐下载中列出的<code>msi</code>/<code>pkg</code>。二者差别是：<code>zip</code>下载后需要解压然后自己设置一些变量，<code>msi</code>和<code>pkg</code>都是可执行文件，直接点击就可以。我喜欢使用<code>zip</code>方式，因为我认为这种更新更方便，毕竟什么都是自己在配置。</p><blockquote><p>Golang自从1.5版本之后就是自举实现，如果你想自己编译，则需要下载<code>推荐下载</code>中的源码，并且你自己的电脑上也要有Go环境。</p></blockquote><h3 id="2-Golang安装"><a href="#2-Golang安装" class="headerlink" title="2. Golang安装"></a>2. Golang安装</h3><p>点击下载完之后（我下载的是zip文件），然后解压，我把解压后的文件夹go，移动到<code>D盘根目录上</code>。如果你是使用的<code>msi</code>方式，直接双击运行即可，需要注意它的安装位置（在点击next的时候你也可以改变）。</p><h3 id="3-设置PATH变量"><a href="#3-设置PATH变量" class="headerlink" title="3. 设置PATH变量"></a>3. 设置<code>PATH</code>变量</h3><p>   <code>PATH</code>是一个系统原本就带有变量，它的作用是当你执行一个命令或程序的时候，系统可以检查这个变量中的路径，查找那个程序，这样就不用在程序的安装目录里才能执行程序，这个变量每一个系统都有，Windows和Linux的区别是Windows使用英文的<code>;</code>作为多个路径分割符，而Linux使用英文<code>:</code>作为系统分割符。我们设置这个变量就是把我们的Go程序安装目录下的<code>bin\go.exe</code>和<code>bin\fmt.exe</code>程序可以让系统找到，所以，我们要给<code>APTH</code>环境变量添加一个<code>;GO_INSTALL_PATH\bin</code>。其中<code>GO_INSTALL_PATH</code>就是Go安装的路径。</p><blockquote><p>注意：windows下路径分割符是<code>\</code>,Linux下是<code>/</code></p></blockquote><h3 id="4-设置GOROOT，GOPATH，GOBIN环境变量"><a href="#4-设置GOROOT，GOPATH，GOBIN环境变量" class="headerlink" title="4. 设置GOROOT，GOPATH，GOBIN环境变量"></a>4. 设置<code>GOROOT</code>，<code>GOPATH</code>，<code>GOBIN</code>环境变量</h3><ul><li><code>GOROOT</code>：这个环境变量类似于Java的<code>JAVA_HOME</code>，作用就是告诉系统或者其他需要知道Go的安装位置的一个系统变量</li><li><code>GOPATH</code>：设置变量就是指定你的工作区（文件夹），简单一句话，你要在那个文件夹下写项目。因为开发程序需要依赖一些其他的包（库/别人写的代码），所以你要先下载下来，下载到那个地方，就是这个变量所指的文件夹下。这个文件夹下也有一些结构：<ul><li>bin文件夹：这个文件夹就是存放go编译后可以执行的一些程序</li><li>pkg文件夹：这个文件夹存放的是下载下来的官方的代码或者别人的代码<code>编译后的库</code>。什么叫做库，类似与压缩包，不过这个压缩包是以<code>.a</code>结尾的。</li><li>src文件夹：这个文件夹存放的是下载下来的官方的代码或者别人的代码，我们自己写的代码也是在这个里面。如果不想在一个文件夹里面写程序，可以设置多个<code>GOPATH</code>，或者使用Go1.11版本之后开始支持的模块，这个以后再说吧。</li></ul></li><li><code>GOBIN</code>：这个变量可以不用设置，如果设置好<code>GOPATH</code>的话。这个变量是设置Go下载下来的程序<code>编译成可执行程序后的位置</code>。这个和<code>GOPATH/pkg</code>的区别就是: <code>GOBIN</code>是go可以下载别人的代码，然后编译成可以执行的程序，然后执行，这个等一会就看到，而<code>GOPATH/pkg</code>则是我们写的代码需要引用别人的代码（在<code>GOPATH/src</code>中），我们总不能把别人的代码编译成程序然后在自己的代码中调用吧，所以需要把别人的代码编程一种库的形式使用，类似与Java中的<code>jar</code>文件（其实jar文件就是一个压缩文件）。</li></ul><p>说了这么多，也要开始设置动手设置一下吧：</p><p>右击<code>此电脑</code> -&gt; 点击<code>属性</code> -&gt; 点击左侧的<code>系统高级设置</code> -&gt; 点击弹出框中的<code>环境变量</code>,然后看图吧：<br><img src="1.png" alt="步骤一"></p><p><img src="2.png" alt="步骤二"></p><p><img src="3.png" alt="步骤三"> </p><blockquote><p>设置上面的三个变量。</p></blockquote><p><img src="4.png" alt="给go添加到PATH上"></p><h3 id="5-检查一下吧！看看可不可以得到Go的一些信息："><a href="#5-检查一下吧！看看可不可以得到Go的一些信息：" class="headerlink" title="5. 检查一下吧！看看可不可以得到Go的一些信息："></a>5. 检查一下吧！看看可不可以得到Go的一些信息：</h3><p>   打开一个操作系统的终端，然后输入<code>go version</code>和<code>go env</code>看看你都可以看到什么。</p><h2 id="选择一个开发工具"><a href="#选择一个开发工具" class="headerlink" title="选择一个开发工具"></a>选择一个开发工具</h2><p>推荐工具</p><ul><li>LiteIDE（没用过）</li><li>GoLand（收费，装了，不经常使用）</li><li>VsCode（挺好的，我习惯使用的）</li></ul><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>如果你使用vscode开发的话，你需要安装Go插件，当你使用vscode打开第一个go文件时，会提醒你是否安装一些go的工具，如果你点击确定，含有可能下了半天还没有下载下来，这是因为vscode支持的go的一些工具是google服务器上的，所以肯有可能下载失败。百度你也可以搜，有很多教程，但是最好的解决方式就是设置一个代理。可以是你所理解的代理，也可以是其他大佬给我们提供的代理。<br>我这里推荐使用：<a href="https://goproxy.io/" target="_blank" rel="noopener">https://goproxy.io/</a><br>访问这个网址，里面有教程。或者我直接告诉你：就是再设置一个环境变量<code>GOPROXY</code>,值就是:<code>https://goproxy.io</code>，设置方法你应该会了。设置完成后，你可以再次运行<code>go env</code>命令，找找输出列表中<code>GOPROXY</code>的值是不是设置的那个，然后你再试试是否可以下载。</p><h2 id="Hello-world-for-go"><a href="#Hello-world-for-go" class="headerlink" title="Hello world for go"></a>Hello world for go</h2><p>在<code>GOPATH/src</code>新建一个文件夹，然后在新建一个名为hello.go的文件<br>内容：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello world for go!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后打开终端，执行<code>go run hello.go</code>试试看！<br><img src="run.png" alt="运行结果"></p><h2 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h2><p>Go和开源有着很重要的关系，以后就会知道！</p><p>在GitHub上有两本Go开源书籍：</p><ul><li><a href="https://github.com/golang101/golang101" target="_blank" rel="noopener">https://github.com/golang101/golang101</a></li><li><a href="https://github.com/chai2010/advanced-go-programming-book" target="_blank" rel="noopener">https://github.com/chai2010/advanced-go-programming-book</a><blockquote><p>这两本书讲的比较深</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>终于要开始写博客</title>
      <link href="/2019/11/22/2019-start/"/>
      <url>/2019/11/22/2019-start/</url>
      
        <content type="html"><![CDATA[<p>为什么说我是“终于”要开始写博客了呢？因为对于博客，我努力尝试过很多次最终的结果：现在开始写博客。这其中每次都是因为不同的想法。</p><p>第一次想写博客是因为我从大一学会Java Web后自己想做一个博客系统然后在上面写，可惜自己前端知识特别差，那当时看到CSS就头痛，更没用过相关的框架，努力了一些Bootstrap框架后就放弃了，然后使用了有道云笔记。<br>第二次想写博客是因为在一个群里，群主要举办一个活动，然后想参加互动必须要准备一个博客，我就草草的准备了一个。之后想再上面写点东西，发现自己不知道写什么，也不知道自己有什么可以写的。不久之后也就忘了。<br>之后也有很多次想过，想的时候感觉自己可以做好，但是总以失败告终；比如想在掘金上写一点东西，自己开始写的时候，总是发现自己以为懂的东西，给别人将却讲不出来……</p><p>为什么今天我又开始，这次会不会又再次放弃呢？说实话，我也不知道，只是最近读了一些书，回想了过去大学三年，想了想这三年我学过的知识，用过的技术，才发现我什么都没有留下了，能做的不过是接别人的话，顺势装个x。所以，我现在开始想写博客原因有三个，其一：我要现在开始准备为我的毕业做“总复习”，把以后找工作的知识点，以前用过的技术，总体上复习一下，对使用的技术及其原理都要做一些了解，所以我要找个地方记录，没有选择使用笔记的方式而选择客是因为，我想把我所理解的知识分享出去，如果错误也希望有人可以反馈给我，不知等我用的到时候才发现；其二：我大一暑假，我当时注意到Go语言，并且开始找了一些视频学习，之后就是找了一些书看看，总体掌握的很差。也是最近几天，登录管看到biezhi大佬的<code>代码真香</code>频道，发现他的Go语言视频已经有一年没有更新过了，我就有了一个打算：边学习边录制视频交给别人。叫别人一个简单的知识点容易，但是要教一套语言使别人可以入门，要有很多课程设计，知识规划和总结，所以就想写博客，一作为自己对Go知识点的梳理，二作为Go视频中知识点的补充。这两个原因算是我开始写博客的主要原因。如果要多说一个原因，那就是，如你所见，我的文笔并不好，我也想借机练习一下。</p><p>2019也快结束了，我也快要开始找工作了，只希望接下来的几个月可以好好学习知识，充实自己，做好计划的每一件事。2019亦结束，亦开始！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
