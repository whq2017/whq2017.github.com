<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>操作系统之同步与死锁</title>
      <link href="/2019/11/27/concurrent-and-deadlock/"/>
      <url>/2019/11/27/concurrent-and-deadlock/</url>
      
        <content type="html"><![CDATA[<h2 id="并发的原理"><a href="#并发的原理" class="headerlink" title="并发的原理"></a>并发的原理</h2><p>操作系统的核心问题是关于进程和线程的管理：</p><ul><li>多道程序设计技术：管理单处理器系统中的多个进程。</li><li>多处理技术：管理多处理器系统中的多个进程</li><li>分布式处理技术：管理多台分布式计算机系统中多个进程的执行。</li></ul><p>其中”多道”，”多处理器”，”多台”都是指多个程序可以同时运行（重叠执行或者交替执行）。如果多程序同时独立运行则问题可能很少，但是如果多程序之间有数据的共享，硬件资源的使用，都会出现很大的问题。所以操作系统或者程序本身要处理这些问题。</p><blockquote><p>虽然CPU也是一种资源，但是多进程对CPU使用权的进程是<code>进程调度</code>问题。二者的区别是，一个是谁先执行的问题，一个是怎么（谁先）使用资源的问题。</p></blockquote><p>并发会出现什么问题呢？<br>举个例子：两个进程同时使用一个变量counter,对counter同时运行counter++操作。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// counter ++ 本质操作：</span>counter <span class="token operator">=</span> counter <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// CPU执行时的操作: register 表示寄存器</span><span class="token keyword">register</span> <span class="token operator">=</span> counter<span class="token punctuation">;</span><span class="token keyword">register</span> <span class="token operator">=</span> <span class="token keyword">register</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>counter <span class="token operator">=</span> <span class="token keyword">register</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于CPU对进程的切换会导致执行三个执行命令的不确定就会导致一些问题: （P1表示进程1，P2表示进程2，这里使用图片）<br><img src="sample_1.png" alt="CPU执行示例"></p><p>P1和P2对counter都进行了加一操作，但是最终结果却只有一个成功了（被覆盖）。所以如果不对counter的访问进行一些控制，结果可能是4，5，6。<br>通过上面的例子，可得出：多线程或者进程在读写一个共享数据时，结果依赖于他们执行的相对时间，这种情形就形成了<code>竞争</code>。</p><p>操作系统为什么要关注同步相关的问题？<br>因为每一个进程都有自身的数据和对硬件资源的使用，操作系统必须保护每一个进程的数据和物理资源，避免其他进程的无意干扰。例如打印机设备，如果操作系统不对其进程管理，则每一个进程都是用，那么打印出来的结果可能都不是任何程序想要看到的。</p><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>进程之间的交互可分为：</p><ul><li>进程间相互不知道对方的存在：这种情况更多的发生在硬件资源的请求上，进程都想要请求一个资源，这是操作系统知道这个硬件资源的使用情况，所以需要操作系统对进程的请求做处理。<ul><li>潜在的控制问题：互斥、死锁（可复用的资源）、饥饿</li></ul></li><li>进程间接知道对方的存在：这个情况是指进程间通过访问共享的数据区或对象，进程知道存在其他的进程访问，但是不知道具体是什么进程。比如I/O缓冲区。<ul><li>潜在的控制问题：互斥、死锁（可复用的资源）、饥饿、数据一致性</li></ul></li><li>进程直接知道对方的存在：进程明确知道一起合作的进程是谁（即通过进程ID通讯）。<ul><li>潜在的控制问题：死锁（可消费的资源）、饥饿</li></ul></li></ul><p><img src="summary.png" alt="进程同步概览"></p><blockquote><p>在计算机世界中，很多问题的解决方案或多或少都会存在一些问题，而且一些问题的解决方案会带来其他的问题。<br>比如：为了解决多进程间合作运行，需要同步，通信，但是解决同步和通信的方法又会带来死锁等问题。</p></blockquote><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>什么是临界区呢？说白了，就是可能会被多个线程执行时会出错的代码语句集合（没有两个进程可以在他们的临界区内同时执行）。比如，上面例子的<code>counter++</code>，这句就要放在临界区内，防止多进程/线程对数据的读写出现问题。<br><img src="critical.png" alt="临界区图示"></p><ul><li>进入区：实现进入临界区时的请求许可代码段</li><li>退出区：临界区结束后的释放请求许可的代码段</li><li>剩余区：退出区之后的代码所属的代码段</li><li>临界区：只能有一个进程执行的代码段</li></ul><p>临界区问题的解决方案所需的要求：</p><ul><li>互斥（mutual exclusion）：如果有一个进程在临界区内运行，那么其他进程不能进入执行</li><li>进步（progress）：如果临界区内没有进程执行，并且有进程想进入，那么只有哪些不在剩余区内执行的进程可以参加选择。</li><li>有限等待（bounded waiting）：如果一个进程想要进入临界区，当他发起请求到可以进入必须具有有限的时间内。</li></ul><p>其实还存在一个问题，就是：进程在进入区执行时，那么怎么保证只有一个进程获取许可呢？这其实就需要硬件的支持才可以。</p><blockquote><p>如果想在软件方面支持，可以参考<code>Peterson解决方案</code>，这个解决方案放在现在的CPU指令执行方式，可能并不能保证正确性。<br>通过软件实现对临界区的保护方式称为<code>加锁</code>机制。</p></blockquote><p>怎么样才算互斥呢？或者说互斥的要求是什么：</p><ol><li>必须强制是是互斥：对与相同资源或共享对象的临界区的所有进程中，一次只允许一个进程执行。</li><li>一个在非临界区停止的不能干涉其他进程</li><li>绝不允许出现需要访问临界区的进程被无限推迟的情况</li><li>如果当前临界区没有任何进程，则只要有进程想要进入，则可以立即进入</li><li>对于相关进程的执行滚速度和处理器数目没有要求</li><li>一个进程驻留在临界区中的事件必须是有限度的。<blockquote><p>—- 《操作系统精髓和设计原理 P144》</p></blockquote></li></ol><p>创建实现互斥的方法：</p><ol><li>由并发执行的进程担负这个职责，这叫做软件方法</li><li>使用专门的机器指令</li><li>使用操作系统或程序设计语言中提供支持，比如Go的协程则是在语言级别上支持</li></ol><h3 id="硬件上支持同步"><a href="#硬件上支持同步" class="headerlink" title="硬件上支持同步"></a>硬件上支持同步</h3><p>使用硬件支持其本质就是寻找一个<code>原子性</code>的指令，保证同一时刻只能有一个进程/线程成功。所以，对于单CPU环境，临界区问题只需要在修改共享变量时禁用终端就可以实现；但是对于多处理器结构，禁用中断需要消耗需要性能，而且会影响系统其他功能。所以现在对于多处理器系统，需要硬件提供硬件指令，用于检测和修改字的内容，或者原子性的交换两个字。<code>CAS原理</code>为这提供了一个思路：<br><code>CAS(Compare-and-Swap)</code>,即<code>比较并替换</code>，CAS需要三个操作数：需要读写的内存地址V、进行比较的值A，需要写入的新值B。当且仅当V的值等于A时，CAS才会通过原子的方式用新值B更新V的值，否则不会执行任何操作。</p><blockquote><p>CAS的含义：认为V的值应该是A，如果是，(说明没有任何其他的进程更改过)，那么就可以将V的值更新为B，否则不修改并告诉V的值实际是多少。 —- 《Java并发编程实战 P263》</p></blockquote><p>硬件提供的特有指令可以抽象为两种形式：<code>test_and_set()</code>,<code>compare_and_swap()</code></p><blockquote><p>术语介绍：<code>忙等待</code>或者叫<code>自旋等待</code>指的是进程在得到临界区访问权之前，他只能继续执行测试变量的指令来得到访问权，除此之外不能做其他事情。 —- 《操作系统精髓和设计原理 P144》</p></blockquote><p>对<code>test_and_set()</code>指令进行抽象则可以表示为：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 指令test_and_set的定义</span><span class="token keyword">boolean</span> <span class="token function">test_and_set</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> <span class="token operator">*</span>target<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">boolean</span> rv <span class="token operator">=</span> <span class="token operator">*</span>target<span class="token punctuation">;</span>    <span class="token operator">*</span>target <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> rv<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// -------------------------</span><span class="token comment" spellcheck="true">// 采用指令test_and_set的互斥实现</span><span class="token keyword">do</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果没有得到期望的false值，则一直处于执行while循环</span>    <span class="token comment" spellcheck="true">// 直到临界区的进程执行退出区的代码段</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">test_and_set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* do nothing */</span>    <span class="token comment" spellcheck="true">/* critical section */</span>    lock <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// quit section</span>    <span class="token comment" spellcheck="true">/* remainder section */</span><span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对<code>compare_and_swap()</code>指令进行抽象则可以表示为：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 指令compare_and_swap的语义解释</span><span class="token keyword">int</span> <span class="token function">compare_and_swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>value<span class="token punctuation">,</span> <span class="token keyword">int</span> expected<span class="token punctuation">,</span> <span class="token keyword">int</span> new_value<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token operator">*</span>value<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 测试原来的值是否被其他进程改变，如果没有改变，则设置新值，否则返回 </span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span>value <span class="token operator">==</span> expected<span class="token punctuation">)</span>        <span class="token operator">*</span>value <span class="token operator">=</span> new_value<span class="token punctuation">;</span>    <span class="token keyword">return</span> temp<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 采用指令compare_and_swap的互斥实现</span><span class="token keyword">do</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 测试期望值是否是0，即退出条件是否成立</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">compare_and_swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* do nothing */</span>    <span class="token comment" spellcheck="true">/* critical section */</span>    lock <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 退出段</span>    <span class="token comment" spellcheck="true">/* remainder section */</span><span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>以上两种虽然满足互斥要求，但是对于有限等待并没有满足。</p></blockquote><p>有界等待互斥的test_and_set()实现：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 共享数据结构，都初始化为false</span><span class="token keyword">boolean</span> waiting<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// n是进程数</span><span class="token keyword">boolean</span> lock<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 表示是否允许进入</span><span class="token keyword">do</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 将要执行的进程</span>    waiting<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    key <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>waiting<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>        key <span class="token operator">=</span> <span class="token function">test_and_test</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 取消自己的等待</span>    waiting<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* critical section */</span>    <span class="token comment" spellcheck="true">// 这个while循环时寻找下一个可用的进程</span>    <span class="token comment" spellcheck="true">// 为了让每一个进程的等待时间最大为n-1次执行时间。</span>    j <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> n<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>j <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>waiting<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        j <span class="token operator">=</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> n<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 退出区代码 </span>    <span class="token keyword">if</span><span class="token punctuation">(</span> j <span class="token operator">==</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果没有新的进程等待，则直接退出</span>        lock <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果找到下一个等待的进程，则直接设置其进入临界区</span>        waiting<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* remainder section */</span><span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>硬件指令方法的特点</strong>：<br>优点：</p><ul><li>适用于在单处理其或共享内存的多处理器上的任何数目的进程</li><li>简单且易于证明</li><li>支持多个临界区，每个临界区可以用自己定义的变量定义<br>缺点：</li><li>使用了忙等待，比较消耗cpu时间</li><li>可能产生饥饿：当一个进程离开临界区后，其他进程再次进入是随意的，即有些进程会进入无线等待，上面最后一个实现可以解决。</li><li>可能死锁：这种是在单处理器下，当一个进程获得临界区后，却被CPU让给更高优先级的进程，但是更高优先级的进程也想使用临界区，这样，一个要被执行但是无法执行，一个可以释放资源，但是没有机会释放资源，就会导致死锁问题。</li></ul><blockquote><p><code>饥饿</code>: 指一个可运行的进程尽管能继续执行，但是被调度器无期限的忽略，而不能被调度执行的情况。<br><code>死锁</code>: 两个或者两个以上的进程因为每一个而进程都在等待其他进程做完某些事情而不能继续执行的情况。</p></blockquote><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p><code>信号量</code>是操作系统和用于提供并发性的程序设计语言的一种同步机制。即信号量是在操作系统和程序设计语言层面上为开发程序提供的一种同步机制。例如Go语言通过通道传递信号，控制另一个线程（协程）的执行。</p><blockquote><p>除了<code>信号量</code>外，还有互斥量，管程，条件变量，消息传递等。</p></blockquote><p>信号量最早是由荷兰的<code>Dijkstra</code>提出，其主要思想是：两个或者多个进程可以通过简单的信号进行合作，一个进程可以<strong>被迫</strong>在某一位置停止，直到它接受到一个特定的信号。<br>通常可把信号量看作一个具有整型数值的变量，在它之上定义三个操作：</p><ul><li>一个信号量可以被初始化成<strong>非负数</strong>。</li><li>操作wait()最初称为P(荷兰语proberen，测试)， 其使信号量减一，如果信号量值变成负数，则执行wait()的进程被阻塞。</li><li>操作signal()最初被称为V(荷兰语verhogen，增加)，其使信号量加一，如果值小于或者等于零，则被wait()操作阻塞的进程被解除阻塞。<blockquote><p>wait()和signal()操作应该为一个原子操作。</p></blockquote></li></ul><p>对于信号量的解释：<br>开始时，信号量的值为0或者整数。如果该值为正数，则它的值等于发出wait()操作后可立即继续执行的进程数量。如果该值为0（或者由于<strong>初始化</strong>，或者由于有等待信号量初值的进程<strong>已经等待</strong>），则发出wait()操作的下一个进程会被阻塞，此时该信号量的值变成负数。之后，每一个后续的wait()操作都会使信号量的负值更大（即负数方向数值增大）。该数值等于正在等待解除阻塞的进程的数量。在信号量为负值的情形下，每一个signal()操作都会将等待进程中的一个进程解除阻塞。</p><blockquote><p>— 《操作系统精髓与设计原理》</p></blockquote><p>信号量的原语定义：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> semaphore<span class="token punctuation">{</span>    <span class="token keyword">int</span> count<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 可用资源数</span>    queueType queue<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 等待资源进程的队列，直到有资源可用在从里面移除。</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span>semaphore s<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 这里只是wait原语的抽象表示，所以整个函数都是原子性，即可认为`s.count --`操作也是不可分割的。</span>    s<span class="token punctuation">.</span>count <span class="token operator">--</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>count <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 把当前进程插入到队列中 */</span>        <span class="token comment" spellcheck="true">/* 阻塞当前进程 */</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">signal</span><span class="token punctuation">(</span>semaphore s<span class="token punctuation">)</span><span class="token punctuation">{</span>    s<span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>count <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 把进程从队列中删除 */</span>        <span class="token comment" spellcheck="true">/* 把进程插入到就绪队列中 */</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="二元信号量"><a href="#二元信号量" class="headerlink" title="二元信号量"></a>二元信号量</h4><p>如果信号量的值<strong>只能</strong>是0和1，则称这样的信号量为二元信号量。除了二元信号量外的信号量称为<code>计数信号量</code>或者<code>一般信号量</code>。</p><p>由于二元信号量的取值只能是0和1，则可以使用的操作定义：</p><ul><li>一个二元信号量可以初始化成0或1；</li><li>wait()操作检查信号的值，如果为0，则进程执行wait()就会被阻塞。如果值位1，则将值改为0，继续执行该进程；</li><li>signal()操作检查是否有任何进程在该信号上受阻，如果有，那么通过signal()操作，受阻的金册灰姑娘就会被唤醒；如果没有进程受阻，那么值被设为1；</li></ul><p>通过上面的定义，我们可以定义二元信号量原语：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> binary_semaphore<span class="token punctuation">{</span>    <span class="token keyword">enum</span> <span class="token punctuation">{</span>zero<span class="token punctuation">,</span> one<span class="token punctuation">}</span> value<span class="token punctuation">;</span>    queueType queue<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span>semaphore s<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>value <span class="token operator">==</span> one<span class="token punctuation">)</span><span class="token punctuation">{</span>        s<span class="token punctuation">.</span>value <span class="token operator">=</span> zero<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 把当前进程插入到队列中 */</span>        <span class="token comment" spellcheck="true">/* 阻塞当前进程 */</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">signal</span><span class="token punctuation">(</span>semaphore s<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>queue is <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 没有进程请求资源</span>        s<span class="token punctuation">.</span>value <span class="token operator">=</span> one<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 把进程从队列中删除 */</span>        <span class="token comment" spellcheck="true">/* 把进程插入到就绪队列中 */</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还有一个点，就是信号量的阻塞队列的问题：进程按照什么顺序从队列中移除？<br>最公平的最简单的方式就是<code>先进先出(FIFO)</code>，我们把使用这个策略的信号量称为<code>强信号量</code>;如果没有规定进程从队列中移除顺序，则称为<code>弱信号量</code>，这种弱信号可能会产生<code>饥饿</code>，而强信号量则不会。</p><h4 id="信号量的使用–互斥"><a href="#信号量的使用–互斥" class="headerlink" title="信号量的使用–互斥"></a>信号量的使用–互斥</h4><p>这是使用上面的wait()和signal()原语保持进程的互斥，这种可以设置允许多个进程同时访问（当存在多个资源时），对于资源已经没有的情况下，则wait()的进程被阻塞，直到signal()的唤醒。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 进程数</span>semaphore s <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span>count<span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">// 定义的资源个数</span>    <span class="token punctuation">.</span>queue<span class="token operator">=</span> <span class="token function">newQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 阻塞队列</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">P</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">wait</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 临界区</span>        <span class="token function">signal</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 剩余区</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">parbegin</span><span class="token punctuation">(</span><span class="token function">P</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">P</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">,</span> <span class="token function">P</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="信号量的使用–生产者-消费者问题"><a href="#信号量的使用–生产者-消费者问题" class="headerlink" title="信号量的使用–生产者/消费者问题"></a>信号量的使用–生产者/消费者问题</h4><p>并发中最常见的一个问题就是<code>生产者/消费者问题</code>：有一个或者多个生产者生产某种类型的数据，并放置在缓冲区中；有一个消费者从缓冲区中取数据，每次取一项。<br>这个问题的本质就是对缓冲区的控制：</p><ul><li>缓冲区为空时，消费者不能从中移走数据</li><li>缓冲区满时，生产者不能继续向其中添加数据</li></ul><p>对于缓冲区可分为两种方式：</p><ul><li>使用二元信号量或计数信号量控制的无线缓冲区</li><li>使用计数信号量控制的有限缓冲区</li></ul><p>使用二元信号量解决无限缓冲区的生产者/消费者问题：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> n<span class="token punctuation">;</span>binary_semaphore s<span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> delay <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">produce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 生产一个数据</span>        <span class="token function">wait</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 防止其他进程</span>        <span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 临界区，设置数据</span>        n<span class="token operator">++</span> <span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">signal</span><span class="token punctuation">(</span>delay<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 当n为0时，消费者被阻塞，这里是判断消费者是否被阻塞。如果阻塞则唤醒消费者</span>        <span class="token function">signal</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 退出临界区 </span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> m<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 局部变量</span>    <span class="token function">wait</span><span class="token punctuation">(</span>delay<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 判断是否有数据可以被处理</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">wait</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 设置临界区</span>        <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 取出数据</span>        n <span class="token operator">--</span> <span class="token punctuation">;</span>         m <span class="token operator">=</span> n<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 防止生产者改变</span>        <span class="token function">signal</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这里退出了临界区，如果不设置m=n的话，那么下面使用的n可能就会被生产者改变</span>        <span class="token function">consume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 消费数据</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>m <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">signal</span><span class="token punctuation">(</span>delay<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果发现数据已经没有的话，则进入阻塞 </span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">parbegin</span><span class="token punctuation">(</span>producer<span class="token punctuation">,</span> consumer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用计数信号量解决无限缓冲区的生产者/消费者问题：</p><pre class="line-numbers language-c"><code class="language-c">semaphore n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> s <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">produce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">wait</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">signal</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">signal</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 记录生产的数据个数 </span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">wait</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 判断是否有数据可以被消费,如果可以被消费，则计数减一，否则阻塞等待</span>        <span class="token function">wait</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">signal</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">consume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">parbegin</span><span class="token punctuation">(</span>producer<span class="token punctuation">,</span> consumer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用计数信号量解决有限缓冲区的生产者/消费者问题：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">int</span> sizeOfBuffer <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 缓冲区大小</span>semaphore s <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> e <span class="token operator">=</span> sizeOfBuffer<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">produce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">wait</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 增加缓冲区使用的个数</span>        <span class="token function">wait</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 临界区</span>        <span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">signal</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 结束临界区</span>        <span class="token function">signal</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 设置生产的数据个数</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">wait</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 消费一个数据,如果为0，则阻塞</span>        <span class="token function">wait</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 临界区</span>        <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">signal</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">signal</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 减少缓冲区使用的个数</span>        <span class="token function">consume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">parbegin</span><span class="token punctuation">(</span>producer<span class="token punctuation">,</span> consumer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="信号量的使用–信号量的实现"><a href="#信号量的使用–信号量的实现" class="headerlink" title="信号量的使用–信号量的实现"></a>信号量的使用–信号量的实现</h4><p>信号量的本质就是<code>互斥</code>：任何时候只能有一个进程可以操作<code>wait</code>和<code>signal</code>，而<code>wait</code>和<code>signal</code>的操作实现不许保证是<strong>原子原语实现</strong>，即类似于一条指令，一旦调用，必须执行完成，不能执行期间中断。<br>对于这，最简单的方案就是使用<strong>硬件或固件</strong>实现。如果使用软件实现，则可以考虑<code>Dekker算法</code>或者<code>Peterson算法</code>;</p><p>使用硬件支持的方式有：CAS类指令或者中断禁用的方式。</p><p>CAS指令代码举例：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">wait</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">compare_and_swap</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>flag<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不做任何事情 </span>    <span class="token punctuation">}</span>    s<span class="token punctuation">.</span>count <span class="token operator">--</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 减少信号量</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>count <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 进程进入s.queue队列 */</span>        <span class="token comment" spellcheck="true">/* 阻塞该进程 */</span>    <span class="token punctuation">}</span>    s<span class="token punctuation">.</span>flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">signal</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">compare_and_swap</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>flag<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 不做任何事情  */</span>    <span class="token punctuation">}</span>    s<span class="token punctuation">.</span>count <span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 增加信号量，即释放资源</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>count <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 从s.queue队列中移除进程 */</span>        <span class="token comment" spellcheck="true">/* 进程进入就绪队列 */</span>    <span class="token punctuation">}</span>    s<span class="token punctuation">.</span>flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>中断方式类似上面：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">wait</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 禁用中断</span>    s<span class="token punctuation">.</span>count <span class="token operator">--</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 减少信号量</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>count <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 进程进入s.queue队列 */</span>        <span class="token comment" spellcheck="true">/* 阻塞该进程 */</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 允许中断</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">signal</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 禁用中断</span>    s<span class="token punctuation">.</span>count <span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 增加信号量，即释放资源</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>count <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 从s.queue队列中移除进程 */</span>        <span class="token comment" spellcheck="true">/* 进程进入就绪队列 */</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 允许中断</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>什么是管程？我的理解就是防止开发人员错误使用信号量等方式而导致程序出现问题的一种手段。比如，信号量的wait和signal的调用，如果存在一个程序只调用wait但是不调用signal则程序就会出现问题。<br>为了防止上面的情况发生就产生了<code>管程</code>：资源的请求和释放，以及进程的阻塞都有管程处理，开发人员只需要在管程内写临界区代码就可以了。</p><p><img src="monitor.png" alt="管程示意图"><br>管程是由一个或多个进程、初始化序列和局部数据组成的<strong>软件模块</strong>,主要特点：</p><ul><li>局部变量只能被管程的过程访问，任何外部过程够不可以访问</li><li>一个进程通过管程的一个过程进入管程</li><li>在任何时候，只能一个进程在管程中执行，调用管程的任何其他进程都被阻塞，以等待管程可用。<blockquote><p>管程类型属于ADT类型，提供一组由程序员定义的，在管程内互斥的操作。 — 《操纵系统概念 P189》</p></blockquote></li></ul><blockquote><p>一个很好的管程例子就是Java的同步：synchronized修饰的同步块。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Example</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="java_monitor.png" alt="反编译Example"></p></blockquote><h3 id="同步的一些问题"><a href="#同步的一些问题" class="headerlink" title="同步的一些问题"></a>同步的一些问题</h3><p>这里介绍一些常见的同步问题：缓冲区相关的生产者消费者问题，读者/写者问题和哲学家问题。</p><h4 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h4><p>关于使用信号量处理的这类问题可以看上面关于信号量的介绍，这里说一下关于使用管程。</p><p>管程类型中定义初始化块，函数。</p><p>管程定义：</p><pre class="line-numbers language-c"><code class="language-c">monitor boundedbuffer<span class="token punctuation">;</span><span class="token keyword">char</span> buffer <span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 分配N个数据项空间</span><span class="token keyword">int</span> nextin<span class="token punctuation">,</span> nextout<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 缓冲区指针</span><span class="token keyword">int</span> count<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 缓冲区中的数据项个数</span>cond notfull<span class="token punctuation">,</span> notempty<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 为同步设置的条件变量,条件成立才可进入到管程中</span><span class="token keyword">void</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token keyword">char</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> N<span class="token punctuation">)</span> <span class="token function">wait</span><span class="token punctuation">(</span>notfull<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 缓冲区满，阻塞等待消费</span>    buffer<span class="token punctuation">[</span>nextin<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>    nextin <span class="token operator">=</span> <span class="token punctuation">(</span>nextin <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> N<span class="token punctuation">;</span>    count <span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token function">signal</span><span class="token punctuation">(</span>notempty<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 释放任何一个等待消费的进程</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">take</span><span class="token punctuation">(</span><span class="token keyword">char</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">wait</span><span class="token punctuation">(</span>notempty<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 缓冲区空，阻塞等待</span>    x <span class="token operator">=</span> buffer<span class="token punctuation">[</span>nextout<span class="token punctuation">]</span><span class="token punctuation">;</span>    nextout <span class="token operator">=</span> <span class="token punctuation">(</span>nextout <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> N<span class="token punctuation">;</span>    count <span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token function">signal</span><span class="token punctuation">(</span>notfull<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 释放任何一个等待添加数据的进程</span><span class="token punctuation">}</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 缓冲区初始化为空</span>    nextin <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    nextout <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>管程的使用：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> x<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">produce</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">append</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> x<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">take</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">consumer</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">parbegin</span><span class="token punctuation">(</span>producer<span class="token punctuation">,</span> consumer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h4><p>生产者-消费者问题是两者的操作都会对数据产生影响，而读者-写者问题中，读者不会对共享数据产生影响，只有写操作会产生影响的同步模型。<br>读者-写者问题定义：有一个多进程共享的数据区，这个数据区可以是一个文件或者一块内存空间，或者是一组寄存器。对于这个数据区，可以允许多个进程同时读取里面的数据，但是只能同步操作数据。<br>即成立的条件：</p><ul><li>任意多的读进程可同时读共享数据区</li><li>一次只有一个写进程可以写共享数据区</li><li>如果一个写进程正在写文件，禁止任何读进程读文件</li></ul><p>从上可以分出来两个问题：当读写进程同时到来时，实现读取数据，还是先写数据。</p><ol><li>读者优先</li></ol><p>这种情况是当有读写进程时，写进程先等待所有的读进程就绪后再操作。这种其实可能会导致写进程进入饥饿状态。<br>使用信号量的实现方式：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> readcount<span class="token punctuation">;</span>semaphore x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> wsem <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// wsem 信号量是否有写进程已经在访问共享数据区</span><span class="token keyword">void</span> <span class="token function">readder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">wait</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 临界区</span>        readcount <span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 增加一个读进程</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>readcount <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>             <span class="token function">wait</span><span class="token punctuation">(</span>wsem<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果有进程正在写，则等待，否则设置不允许进程写</span>        <span class="token function">signal</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">READUNIT</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 读取资源</span>        <span class="token function">wait</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 临界区</span>        readcount <span class="token operator">--</span> <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 表示一个读进程结束</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>readcount <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>             <span class="token function">signal</span><span class="token punctuation">(</span>wsem<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果没有进程读，则唤醒释放写信号，可以让写进程获取资源</span>        <span class="token function">signal</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">wait</span><span class="token punctuation">(</span>wsem<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 开始写时，请求资源，如果没有进程在读，则可以直接进入写，则否阻塞</span>        <span class="token function">WRITEUNIT</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">signal</span><span class="token punctuation">(</span>wsem<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    readcount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">parbegin</span><span class="token punctuation">(</span>reader<span class="token punctuation">,</span> writer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>写者优先</li></ol><p>写着优先保证了当一个进程写时，其他读进程都必须阻塞，等待写操作完成后才可以再读取。<br>使用信号量的实现方式：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> readcount<span class="token punctuation">,</span> writecount<span class="token punctuation">;</span>semaphore x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> z <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>         wsem <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 写信号，当其他进程在读些时，阻塞等待 </span>        rsem <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 读信号，用于当写操作时，阻塞读进程</span><span class="token keyword">void</span> <span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">wait</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 临界区</span>            <span class="token function">wait</span><span class="token punctuation">(</span>rsem<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 当写进程正在执行时，读进程不能读取，在这里阻塞</span>                <span class="token function">wait</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 临界区</span>                    readcount<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 添加一个读进程</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>readcount <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token function">wait</span><span class="token punctuation">(</span>wsem<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果存在读进程开始读取时，设置写进程不能执行</span>                <span class="token function">signal</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">signal</span><span class="token punctuation">(</span>rsem<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 释放共享区的资源，可以让写进程进入执行</span>        <span class="token function">signal</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">READUNIT</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">wait</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 临界区</span>            readcount<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>readcount <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token function">signal</span><span class="token punctuation">(</span>wsem<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 当没有读进程后，释放请求，可以让写进程执行</span>        <span class="token function">signal</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">wait</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 临界区</span>            writecount<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 增加一个写进程</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>readcount <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>                <span class="token function">wait</span><span class="token punctuation">(</span>rsem<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果存在进程在读，则等待，否则则阻塞所有读进程执行</span>        <span class="token function">signal</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">wait</span><span class="token punctuation">(</span>wsem<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 阻塞其他写进程执行</span>        <span class="token function">WRITEUNIT</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">signal</span><span class="token punctuation">(</span>wsem<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">wait</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 临界区</span>            writecount <span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 减少写进程</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>writecount <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token function">signal</span><span class="token punctuation">(</span>rsem<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果没有写进程，则释放资源，让资源给读进程</span>        <span class="token function">signal</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    readcount <span class="token operator">=</span> writecount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">parbegin</span><span class="token punctuation">(</span>reader<span class="token punctuation">,</span> writer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的信号情况可为：<br>| 系统中的进程状态 |  信号情况 |<br>|:–|:–|<br>|系统中只有读进程 | 设置wsem、没有队列 |<br>|系统中只有写进程 | 设置wsem和rsem、写进程在wsem上排队 |<br>|既有读进程，又有写进程，但读者优先 | 由读进程设置wsem、有写进程设置rsem、所有写进程在wsem上排队、一个读进程在rsem上排队、其他读进程在z上排队 |<br>|既有读进程，又有写进程，但写者优先 | 由写进程设置wsem、由写进程设置rsem、写进程在wsem上排队、一个读进程在rsem上排队、其他读进程在z上排队 |</p><blockquote><p>对于读者-写者问题也可以使用消息传递的方式解决。</p></blockquote><h4 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h4><p>哲学家就餐问题针对的是<code>多进程之间分配多个资源，并且不会出现死锁和饥饿</code>的同步模型。<br>具体描述：5个哲学家，他们的生活只有思考和吃饭。他们共用一个圆桌，每一位都有一把椅子。在桌子中央有<strong>一碗米饭</strong>，在桌子上有<strong>5根筷子</strong>。当一位哲学家思考时，他与其他同时不交流。当他感觉饥饿时，拿起与他相近的两根筷子（筷子在他左边和右边）。一个哲学家只能一次拿起一个筷子，而且不能从别人手里拿筷子。当一个饥饿的哲学家同时拥有两根筷子时就可以吃，吃完后，放下筷子并开始思考。</p><p><img src="philosophers_problem.png" alt="哲学家问题图示"></p><blockquote><p>图来源于：由Benjamin D. Esham / Wikimedia Commons，CC BY-SA 3.0，<a href="https://commons.wikimedia.org/w/index.php?curid=56559" target="_blank" rel="noopener">https://commons.wikimedia.org/w/index.php?curid=56559</a></p></blockquote><p>一个简单的解决方法就是每一个筷子使用一个信号量，当一个哲学家左右两边的筷子（信号）都是可用时，则它就可以吃饭了。</p><pre class="line-numbers language-c"><code class="language-c">semaphore chopstick<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">do</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 思考</span>        <span class="token function">wait</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">wait</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 吃饭</span>        <span class="token function">signal</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">signal</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 思考</span>    <span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实这种方案还是存在一些问题：</p><ol><li>相邻的两个人不能吃饭</li><li>有可能导致死锁：当五个人都拿起筷子，则每一个都等待别人释放另一个筷子，这就造成了死锁。</li></ol><p>那么怎么处理死锁呢？造成死锁的必须条件又是什么？</p><hr><hr><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>操作系统引入了多进程或多线程运行，导致资源的不能合理使用，有引入了同步手段使多进程或多线程之间合作，控制对资源的访问。但是使用同步中，我们也发现了会产生两个问题：<code>死锁</code>、<code>饥饿</code>。</p><ol><li>死锁：一组相互竞争系统资源或进程通信的进程间的“永久”阻塞。</li><li>饥饿：指一个可运行的进程始终得不到CPU资源，导致无法运行。</li></ol><h3 id="死锁的原理"><a href="#死锁的原理" class="headerlink" title="死锁的原理"></a>死锁的原理</h3><p>当一组进程内的每一个进程偶的在等待一个事件，而这个事件只能由这组进程中的另一个进程引起，那么这组进程就处于死锁状态。</p><p>在正常情况下，一个进程使用资源的步骤：</p><ol><li>向操作系统申请，如果资源被其他进程占用，则申请的进程一直处于等待，直到获得该资源</li><li>使用资源</li><li>释放资源<blockquote><p>资源通常可以分为：</p><ul><li>可重用资源：指一次只能提供一个进程使用，并且不会由于使用而耗尽的资源</li><li>可消耗资源：指可以被创建（生产）和销毁（消耗）的资源</li></ul></blockquote></li></ol><p>但是当有进程申请的资源一直得不到则就进入了死锁。<br>例如：一个系统有一台打印机和一个DVD驱动器，假如进程A占用DVD驱动器而进程B占用打印机。如果进程A申请打印机而进程B申请DVD驱动器，那么这就产生了死锁。</p><p>死锁产生需要什么条件呢？通过之前的例子，可得出：</p><ul><li>互斥：一次只能一个进程使用，其他进程只能等待该进程使用完成才可以在使用。</li><li>占有且等待：一个进程占有一个资源，并且等待另一个资源，而该资源被其他进程占有。</li><li>不可抢占：资源不能被强制让出，只能由拥有该资源的进程主动释放。</li><li>循环等待：存在一个封闭的进程链，这个链中的每一个进程至少占有此链中下一个进程所需的一个资源。<blockquote><p>第四个条件<code>循环等待</code>其实暗含了在了<code>占有并等待</code>中，换句话说，其实前三个条件就直接导致了第四个条件的成立，即第四个条件不可解。</p></blockquote></li></ul><blockquote><p>上面的四个条件是造成死锁的充分必要条件。</p></blockquote><p>怎么描述死锁呢？通常都是通过一个称为<code>系统资源分配图</code>的<code>有向图</code>表示。<br><img src="res.png" alt="系统资源分配图"><br><img src="deadlock_res.png" alt="发生死锁"><br><img src="undeadlock_res.png" alt="不发生死锁"></p><p>现在我们已经知道死锁是怎么产生的？那么我们怎么处理死锁呢？其实我们可以考虑一下怎么处理失火：从条件出发，切断条件之一就可以做到。在这里也是，我们只要把四个条件中的某一个条件不成立就可以了。</p><blockquote><p>操作系统对死锁的处理方法：</p><ul><li>通过协议来预防或者避免死锁，确保系统不会进入死锁状态</li><li>可以允许系统进入死锁，然后检测它，并加以恢复。</li><li>可以忽略这个问题，认为死锁不会在系统内发生（大多数操作系统采用，包括Linux和Windows），所以需要用户程序开发人员处理</li></ul></blockquote><h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><p>死锁预防：确保死锁的条件中至少有一个必必要条件不成立</p><ul><li>互斥条件：对于互斥条件，这个条件是必须成立的，如果需要对资源互斥访问，则操作系统必须支持互斥。</li><li>持有且等待：如果这个条件不成立，则可以要求进程一次请求所需要的所有资源，并且阻塞这个进程知道所有请求都完成。但是这样是低效，而且有些进程并不知道自己所需的所有资源。</li><li>不可抢占：<ul><li>如果一个进程请求另一个资源时被拒绝，则该进程释放之前请求到的资源，之后再次重新请求资源。</li><li>如果一个进程请求的资源被另一个进程使用，操作系统可以抢占另一个进程的资源，即使另一个进程被抢占。这种方案对优先级的进程更好。</li></ul></li><li>循环等待：通过定义资源类型的线性访问顺序来预防。如果一个进程已经分配了R类型的资源，那么它接下来请求的资源只能使排在R类型之后的资源类型。我的理解是：死锁发生时，所有进程请求的资源是一个固定集合，每一个进程都想要两种或者更多资源，所以只要这个集合有序，并且使用时也不许一个进程先使用后面的资源，再使用前面的资源，这样就保证了这些进程会在请求一个资源的时候被阻塞，另一个可以运行，所以死锁也就不成立了。</li></ul><h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><p>死锁避免：操作系统事先得到有关进程申请资源和使用资源的额外信息。即约束资源请求，防止必要条件中的至少一个发生。死锁避免和死锁预防的区别是，死锁预防是通过死锁的必须条件至少一个不成立，而死锁避免是允许死锁的条件成立，但是需要一些方法对进程的资源请求做控制，使其不能达到死锁。</p><p>死锁避免的方法：</p><ul><li>如果一个进程的请求会导致死锁，则不启动此进程</li><li>如果一个进程增加的资源请求会导致死锁，则不允许分配。</li></ul><h4 id="安全状态"><a href="#安全状态" class="headerlink" title="安全状态"></a>安全状态</h4><p><code>安全状态</code>，是指系统能按某种进程推进顺序( P1, P2, …, Pn)，为每个进程Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺序地完成。此时称 P1, P2, …, Pn 为<code>安全序列</code>。如果系统无法找到一个安全序列，则称系统处于<code>不安全状态</code>。</p><p>例子：假设系统中有三个进程P1、P2和P3,共有12 台磁带机。进程P1总共需要10台磁带机，P2和P3 分别需要4台和9台。假设在T0时刻，进程P1、P2 和P3已分别获得5合、2台和2台，尚有3台未分配，见下表</p><table><thead><tr><th align="left">进程</th><th align="left">最大需求</th><th align="left">当前需求</th><th align="left">还需</th><th align="left">可用</th></tr></thead><tbody><tr><td align="left">P1</td><td align="left">10</td><td align="left">5</td><td align="left">5</td><td align="left">3</td></tr><tr><td align="left">P2</td><td align="left">4</td><td align="left">2</td><td align="left">2</td><td align="left"></td></tr><tr><td align="left">P3</td><td align="left">9</td><td align="left">2</td><td align="left">7</td><td align="left"></td></tr></tbody></table><p>解题：</p><ol><li>刚开始时，系统给三个进程分配完当前需求，则还剩3个资源可用。</li><li>寻找是否存在一个安全序列，即这三个进程先后执行，资源需求可以满足。</li><li>三个进程排序则可组成：<ol><li>P1, P2, P3: P1需要执行则需要5个资源，不足</li><li>P1, P3, P2: P1需要执行则需要5个资源，不足</li><li>P2, P1, P3: P2需要2个，小于3，则可以；之后P2使用完成后释放资源，则还剩5个满足P1执行，P1执行完成释放资源，P3执行，满足安全序列。</li><li>P2, P3, P1: P2需要2个，小于3，则可以，之后P2释放资源，还剩5个不满足P3执行</li><li>P3, P1, P2: 所剩资源不满足P3执行</li><li>P3, P2, P3: 所剩资源不满足P3执行</li></ol></li><li>安全序列为P2, P1, P3。则只要操作系统按照这个安全序列执行就可以正常执行。</li></ol><h4 id="银行家算法（资源分配拒绝策略）"><a href="#银行家算法（资源分配拒绝策略）" class="headerlink" title="银行家算法（资源分配拒绝策略）"></a>银行家算法（资源分配拒绝策略）</h4><p>对于每种资源类型有多个实例的资源分配系统，现在更多的是使用一种基于<code>安全状态</code>的<code>银行家算法</code>。</p><p>当一个新的进程进入系统时，其应声明可能需要的每一种资源实力的最大数量，这个值不能超过系统资源的总和。<br>当用户申请一组资源时，系统应确定这些资源的分配是否会使系统处于安全状态。如果会则分配资源，否则，进程应该等待直到其他进程释放足够多的资源为止。</p><p>如果要实现银行家算法则需要保存系统资源和进程的一些数据：（n为系统进程的数量，m为资源类型的种类）</p><ul><li><code>Available</code>：长度为m的向量，表示每一种资源的可用实例数量</li><li><code>Max</code>：$n * m$矩阵，定义每一个进程的最大需求。</li><li><code>Allocation</code>：$n * m$矩阵，定义每一个进程现在已经分配的每种资源类型的实例数量。</li><li><code>Need</code>：$n * m$矩阵，表示每一个进程还需要的剩余资源。</li></ul><p>算法描述：</p><ol><li>令Work和Finish分别表示长度m和n的向量。对于$i= 0,1, …, n -1,$初始化$Work = Available$和$Finish[i] = false$;</li><li>查找这样的$i$使其满足：<ol><li>$$Finish[i] == false$$</li><li>$$Need_i \leq Work$$<br>如果没有找到这样的$i$存在，则转到第4步</li></ol></li><li>$$Work = Work + Allocation_i$$<br>$$Finish[i] = true $$<br>返回到第2步。</li><li>如果对<strong>所有i</strong>，有Finish[i] = true, 那么系统处于安全状态。</li></ol><p>代码实现：略(<em>^_^</em>)。</p><h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><p>如果一个系统不采用上面两种方式避免死锁，那么死锁可能出现，这种环境下，系统可以提供：</p><ul><li>一个用来检测系统环境状态从而确定是否出现死锁的算法。</li><li>一个用来从死锁状态种恢复的算法。</li></ul><ol><li>当每种资源只有单个实例的时候<br> 在这种情况下，可以通过资源分配图转化出<code>等待图</code>。然后判断是否有环，如果存在，则说明发生死锁；反之则说明不存在死锁。</li><li>当每种资源可有多个实例的时候<br> 对于这，所使用的算法类似于银行家算法：<ul><li><code>Available</code>：长度为m的向量，表示每一种资源的可用实例数量</li><li><code>Allocation</code>：$n * m$矩阵，定义每一个进程现在已经分配的每种资源类型的实例数量。</li><li><code>Request</code>：$n * m$矩阵，表示当前每个进程的每种资源的当前请求。<br>算法描述</li></ul><ol><li>令Work和Finish分别表示长度m和n的向量。初始化$Work=Available$。对于$i= 0,1, …, n -1$,如果$Allocation_i$不为0，则$Finish[i] = false$，否则$Finish[i] = true$;</li><li>查找这样的$i$使其满足：<ol><li>$$Finish[i] == false$$</li><li>$$Request_i \leq Work$$<br>如果没有找到这样的$i$存在，则转到第4步</li></ol></li><li>$$Work = Work + Allocation_i$$<br>$$Finish[i] = true$$<br>返回到第2步。</li><li>如果对<strong>某个i（0 &lt;= i &lt; n）</strong>，有Finish[i] = false, 那么系统死锁。而且，如果 $Finish[i] == false$,则进程$P_i$死锁。 </li></ol></li></ol><h3 id="死锁恢复"><a href="#死锁恢复" class="headerlink" title="死锁恢复"></a>死锁恢复</h3><p>一旦检测到死锁，常见的恢复策略有（按复杂递增）：</p><ol><li>取消所有死锁的进程</li><li>把每个死锁进程回滚到前面定义的某个检查点，并且重启所有进程</li><li>连续取消死锁进程直到不在存在死锁</li><li>连续抢占资源直到不在发生死锁</li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 进程 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统：进程和线程介绍</title>
      <link href="/2019/11/23/os-process-thread/"/>
      <url>/2019/11/23/os-process-thread/</url>
      
        <content type="html"><![CDATA[<h2 id="基础知识介绍"><a href="#基础知识介绍" class="headerlink" title="基础知识介绍"></a>基础知识介绍</h2><p>“操作系统是什么”这个问题的答案我相信现在玩过电脑的同学应该都知道是什么，但是如果说到“操作系统”内部的一些机制可能就会有些言语不清了吧！<br>我也是这学期开始学习这门课程的，所以请大家跟着我一起梳理操作系统中的重要知识点。</p><p>先说明一点，关于操作系统的历史和分类我感觉还是交给你自己百度吧，我这篇文章将跳过所有历史和分类。如果实在需要一些历史说明我会找一个小空间加上去的。</p><p>我所认为的操作系统核心知识（不服忍着）：</p><ul><li>进程管理</li><li>内存管理</li><li>存储管理</li><li>设备管理</li></ul><h3 id="什么是程序"><a href="#什么是程序" class="headerlink" title="什么是程序"></a>什么是程序</h3><p>对于CPU来说，它只能识别二进制位，而这些二进制位根据不同的环境可以被解释成不同的意义。<code>程序</code>就是一些可以让CPU看懂的二进制位组成（这些位就是所写的代码经过编译后形成的）。但是代码中有一些是<code>指令</code>，还有的是<code>数据</code>，这对CPU来说是不能区分，这就需要操作系统帮CPU指出哪些是指令，哪些是数据，即操作系统把程序的二进制位按照规定的格式加载到内存中。操作系统的这一点“私心”，即只想执行符合它所规定格式的二进制，所以程序就被分成了<code>Windows程序</code>(Windows PE/COFF格式)和<code>Linux程序</code>(ELF格式)等类型。但是总的来说，程序就是 <code>CPU所支持的指令</code> + <code>程序运行所需的数据</code>。从这里我们也就知道了，程序是<code>静态的</code>，无论操作系统把不把它复制进内存，它都在硬盘里面，直到把它删除。</p><h3 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h3><p>进程，又叫做任务，是操作系统对CPU运行的指令和数据集的一种抽象。如果把程序当作一种类型，则加载进内存即是使用该类型创建对象。使用Java的面向对象来说，类是不可变的（静态数据除外），但是类的对象确实可以改变的。</p><p>进程和程序的区别：</p><ul><li>程序是静态的，存放在硬盘上，可以被操作系统读取。</li><li>进程是程序加载到内存后的名称，是让CPU读取执行的。</li><li>进程是动态的。</li></ul><h3 id="进程在内存中的表示形式"><a href="#进程在内存中的表示形式" class="headerlink" title="进程在内存中的表示形式"></a>进程在内存中的表示形式</h3><p>操作系统为了方便管理进程运行时的数据，所以要使用一个数据结构记录进程运行时的环境状态。这个数据结构称为<code>进程控制块</code>(PCB),它是由操作系统创建和管理。<br>PCB结构中包含着数据有：</p><ul><li>标识符：操作系统为了区分进程，给每一个进程分配的id</li><li>状态：进程的运行状态</li><li>优先级：被CPU执行的优先度</li><li>程序计数器：即将被CPU执行的下一条指令地址</li><li>内存指针：程序被加载到内存后的指令和数据的相关指针</li><li>上下文数据：进程在被CPU执行过程中寄存器的数据</li><li>I/O状态信息：被进程所使用的I/O请求记录</li><li>记账信息：进程运行产生的一些统计数据，比如处理器时间总和，使用的时钟数总和等。</li></ul><h2 id="进程的状态和状态转换概念"><a href="#进程的状态和状态转换概念" class="headerlink" title="进程的状态和状态转换概念"></a>进程的状态和状态转换概念</h2><h3 id="三状态模型"><a href="#三状态模型" class="headerlink" title="三状态模型"></a>三状态模型</h3><p><img src="three_model.png" alt="三状态模型图"></p><ul><li>就绪态：操作系统已经加载程序进入内存，并且创建好PCB块，等待CPU执行</li><li>运行态：正在被CPU进行执行</li><li>等待态：由于某些事件（比如等待IO）而不能继续执行的。</li></ul><p>转换事件：</p><ul><li><code>就绪 -&gt; 运行</code>: 由调度程序选择的进程由就绪状态转为被CPU执行的运行态</li><li><code>运行 -&gt; 就绪</code>: 由于进程自愿放弃CPU，或者更高优先级的进程抢占了CPU，又或者进程运行到系统所设置的时间段等。</li><li><code>运行 -&gt; 等待</code>: 由于进程等待某些事件的发生而进入</li><li><code>等待 -&gt; 就绪</code>: 进程等待的事件发生后转入</li></ul><h3 id="五状态模型"><a href="#五状态模型" class="headerlink" title="五状态模型"></a>五状态模型</h3><p><img src="five_model.png" alt="五状态模型图"></p><ul><li>运行态：该进程正在被CPU执行</li><li>就绪态：进程做好了准备，只要有机会就开始执行</li><li>阻塞/等待态：进程在某些事件发生前不能执行</li><li>新建态：刚刚创建的进程，操作系统还没有把它加入可执行进程组中。通常是PCB已经创建好但是还没有加载到内存中的新进程</li><li>退出态：操作系统从可执行组中释放出的进程，或者因为自身停止，或被取消执行</li></ul><p>转换事件：</p><ul><li><code>空 -&gt; 新建</code>：创建执行一个程序的新进程</li><li><code>新建 -&gt; 就绪</code>：操作系统准备好再接纳一个进程时，把一个进程从新建态转为就绪态</li><li><code>就绪 -&gt; 运行</code>：需要一个新进程执行时，有调度器或分派器从就绪态中选择一个执行</li><li><code>运行 -&gt; 退出</code>：当前正在执行的进程表示自己执行完成或者取消</li><li><code>运行 -&gt; 就绪</code>：由于进程自愿放弃CPU，或者更高优先级的进程抢占了CPU，又或者进程运行到系统所设置的时间段等。</li><li><code>运行 -&gt; 阻塞</code>：由于进程等待某些事件的发生而进入</li><li><code>阻塞 -&gt; 就绪</code>：进程等待的事件发生后转入</li><li><code>就绪 -&gt; 退出</code>：这种通常时允许父进程终止子进程的操作系统中可见</li><li><code>阻塞 -&gt; 退出</code>：同上</li></ul><h3 id="七状态模型"><a href="#七状态模型" class="headerlink" title="七状态模型"></a>七状态模型</h3><p><img src="seven_model.png" alt="七状态模型图"></p><ul><li>阻塞/挂起态：进程在外存中并等待一个事件</li><li>就绪/挂起态：进程在外村中，但是只要被载入内存就可以执行</li></ul><p>一些重要的转换事件：</p><ul><li><code>阻塞 -&gt; 阻塞/挂起</code>：如果没有就绪进程，则至少一个阻塞进程被换出（换出到外存中），为另一个没有阻塞的进程让出空间。</li><li><code>阻塞/挂起 -&gt; 就绪/挂起</code>：如果等待的事件发生了，则处于阻塞/挂起状态的进程可以转换到就绪/挂起状态。</li><li><code>就绪/挂起 -&gt; 就绪</code>：如果内存中没有就绪态进程，操作系统需要调入一个进程继续执行</li><li><code>就绪 -&gt; 就绪/挂起</code>：如果释放内存以得到足够的内存空间的唯一方式就是挂起一个就绪态的进程，那么这种转换才会方式。但是通常就绪态更多的是可以直接运行。</li><li><code>新建 -&gt; 就绪/挂起或者新建 -&gt; 就绪</code>：当创建一个进程时，该进程被加入到就绪队列或者加入到就绪/挂起队列中。</li><li><code>阻塞/挂起 -&gt; 阻塞</code>：这种转换比较少见，作为特殊情况下才会出现（和进程调度算法有关）</li></ul><blockquote><p>挂起的用途：这种是由于内存空间不足，由调度算法执行，使一些进程换出到硬盘上。<br>一个挂起的进程，无论是否等待一个事件都不能立即执行</p></blockquote><p>导致进程挂起的原因：</p><ul><li>交换</li><li>其他OS原因</li><li>交互式用户请求</li><li>定时</li><li>父进程请求</li></ul><h2 id="进程的管理"><a href="#进程的管理" class="headerlink" title="进程的管理"></a>进程的管理</h2><p>操作系统的重要功能之一就是管理进程，即对进程的创建、销毁和运行状态进程管理。</p><h3 id="进程的执行模式"><a href="#进程的执行模式" class="headerlink" title="进程的执行模式"></a>进程的执行模式</h3><p>操作系统作为一种中间层软件—对下管理硬件资源，对上为应用程序提供通用接口服务，故应用层软件对硬件资源的合理使用都是由操作系统保证的。CPU对其提供了至少两种执行模式。<br>即对操作系统的执行提供一种叫做<code>特权态</code>或<code>内核态</code>的模式，对用户引用程序提供<code>用户态</code>模式。CPU针对不同模式下执行不同的控制能力。在内核态下，软件具有对CPU以及所有指令，寄存器和内存的控制能力，但是这些对用户态下的软件时不需要的，并且为了安全性也不会提供给用户态下的应用程序。</p><p>那么怎么切换这两种模式呢？在典型情况下，都是由用户程序通过一些系统提供的<code>系统调用</code>或者<code>中断例程</code>执行时，才会由用户态切换到内核态。<br>例如：在64位IA-64体系结构的Intel Itanium处理器，有一个处理器状态寄存器（PSR），包含2位CPL（当前特权级别）域，级别0是最高特权级别，级别3是最低特权级别。Linux使用级别0最为内核态。<br>当中断发生时，处理器就会清空PSR中的位，包括设置CPL域的值设为0。使用<code>irt</code>（中断返回）指令时，会从处理器恢复中断程序的PSR值，即设为用户态值。</p><h3 id="进程的创建过程"><a href="#进程的创建过程" class="headerlink" title="进程的创建过程"></a>进程的创建过程</h3><p>当操作系统准备创建一个进程时，会按照下面的步骤执行：</p><ol><li>给进程分配一个唯一的进程标识符。</li><li>给进程分配内存空间</li><li>初始化进程控制块（PCB）</li><li>设置正确的连接：目标是把新建的进程放到调度器的数据结构中，方便调度器调度。</li><li>创建或者扩充其他数据结构：比如PCB中的记账数据结构。</li></ol><p>上面的步骤是操作系统创建进程时的要做的事情，但是准确一点来说，作为开发者怎么创建一个进程的呢？或者我们是怎么告诉操作系统要运行一个程序的呢？</p><p>答案就是：由当前正在执行的程序告诉操作系统。就比如，当我们双击桌面上的程序快捷键时，桌面应用程序响应了我们的点击事件，然后知道我们要运行这个程序，然后它就告诉操作系统，我给你个程序，用户想运行它，然后操作系统就按照上面的流程<br>为它创建一个进程。这是不是类似于父子关心呢？我们双击的那个程序运行后的进程就是桌面这个进程的孩子。其实现在的操作系统创建进程就是通过父进程创建子进程的方式新建进程，子进程也可以创建其他进程，这样就形成了一个<code>进程树</code>。<br>到了这里你可能会想到操作系统的第一个进程是谁，又是谁创建的呢？这个可以看一下进程上的PID（进程唯一标识）为1的那个就是。Linux上（运行<code>ps -el</code>命令），有一些发行版本是<code>systemd</code>,还有一些发行版本是<code>init</code>。之后所有的进程都是他们创建的（在Linux下<code>任务</code>等同于<code>进程</code>）。作为开发者，本质也是一样的。在Linux上，是使用代码调用系统调用接口<code>fork</code>函数和<code>exec</code>函数。在Windows上，使用<code>CreateProcess</code>函数。</p><p>Windows下CreateProcess函数示例：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;windows.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    STARTUPINFO si<span class="token punctuation">;</span>    PROCESS_INFORMATION pi<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 申请内存 */</span>    <span class="token function">ZeroMemory</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>si<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>si<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    si<span class="token punctuation">.</span>cb <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>si<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ZeroMemory</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pi<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>pi<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 创建子进程 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">CreateProcess</span><span class="token punctuation">(</span>            <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 应用程序名称</span>            <span class="token string">"C:\\WINDOWS\\system32\\mspaint.exe"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 命令，即要运行的程序，这里是打开画板</span>            <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 不继承进程句柄（process handle）</span>            <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 不继承线程句柄（thread handle）</span>            FALSE<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 禁用句柄继承</span>            <span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 不适用创建标志</span>            <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 不使用父进程的已有环境块</span>            <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 不使用父进程的启动目录</span>            <span class="token operator">&amp;</span>si<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 设置新进程的一些特性，比如窗口大小，颜色等</span>            <span class="token operator">&amp;</span>pi <span class="token comment" spellcheck="true">// 创建新进程以及其线程的句柄和标识符</span>            <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Create Process Failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 父进程等待子进程结束</span>    <span class="token function">WaitForSingleObject</span><span class="token punctuation">(</span>pi<span class="token punctuation">.</span>hProcess<span class="token punctuation">,</span> INFINITE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child Complete"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 关闭句柄（释放内存）</span>    <span class="token function">CloseHandle</span><span class="token punctuation">(</span>pi<span class="token punctuation">.</span>hProcess<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">CloseHandle</span><span class="token punctuation">(</span>pi<span class="token punctuation">.</span>hThread<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Linux下fork和exec函数的使用：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 存储子进程id</span>    pid_t     pid<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 复制当前进程来创建子进程</span>    pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 创建失败</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span><span class="token string">"Fork Failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果是子进程</span>        <span class="token comment" spellcheck="true">// 子进程执行逻辑</span>         <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child Process Running....\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 使用一个新程序取代自身</span>         <span class="token function">execlp</span><span class="token punctuation">(</span><span class="token string">"/bin/ls"</span><span class="token punctuation">,</span> <span class="token string">"ls"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 父进程逻辑</span>        <span class="token comment" spellcheck="true">// 父进程等待子进程执行完成</span>        <span class="token function">wait</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child Complete.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>fork</code> 和 <code>exec</code>的区别：<br><code>fork</code>是复制当前进程，即执行这个函数后，会出现两个进程，这两个进程一样，不过有一个区别就是，这个函数返回给这两个进程不同的返回值用于区分不同进程。<br><code>fork</code>在父进程中返回值是子进程的PID，在子进程中返回0。<code>sub_pid = fork();</code>这个语句使创建两个进程。后面就可以根据返回值不同区分不同的进程。<br><strong>注意</strong>：<code>fork</code>创建的子进程和父进程具有相同的代码逻辑，如果没有后面的if做区分，则父子进程执行相同的代码，直到运行结束。<br><code>execlp</code>是<code>exec</code>函数系中的一个，<code>exec</code>是加载一个新的程序取代当前程序，如果代码直接执行<code>exec</code>函数，当前程序就会终止，开始执行新的代码。<br>通过<code>fork</code>和<code>exec</code>组合创建新的程序：先使用fork创建一个当前进程的复制进程，然后根据返回值在子进程中运行<code>exec</code>函数执行一个新的进程。<br>例子：比如在Shell中运行一个程序，Shell就会复制自身，然后再让那个程序代替子进程执行。</p></blockquote><p><img src="fork.png" alt="fork逻辑图"></p><h3 id="进程的销毁"><a href="#进程的销毁" class="headerlink" title="进程的销毁"></a>进程的销毁</h3><p>当程序执行完成后，会发生什么？操作系统大管家，管理着资源，当然是释放这个进程占用的资源啦！不过我们先讨论一下下面问题：</p><ul><li>程序什么时候终止</li><li>程序终止时操作系统做了什么？</li><li>程序之间由父子关系，操作系统怎么处理这些关系出现的问题？</li></ul><p>先回答第一个和第二个问题：程序通过主动调用系统调用函数<code>exit</code>表示自己退出，让操作系统删除自身。每一个进程结束时都会有一个返回值返回给父进程（可以通过系统调用<code>wait</code>获取）。然后操作系统释放该进程之前占用的系统资源：物理和虚拟内存，打开的文件和I/O缓冲区等。但是还有一些情况，就是程序被动终止：</p><ul><li>子进程使用超过他的所分配的资源</li><li>父进程分配给子进程的任务，父进程不在需要</li><li>父进程正在退出，而且操作系统不允许无父进程的子进程继续执行</li><li>父进程可以终止他所创建的子进程</li></ul><p>对于父子关系的进程，操作系统怎么处理？这个答案和操作系统具体实现有关。有的操作系统不允许没有父进程的子进程执行，即如果一个子进程的父进程终止了，那么这个子进程也要终止。这种叫做<code>练级终止</code>。<br>对于其他允许子进程存在的操作系统，操作系统会直接让子进程执行完成。</p><blockquote><p>如果一个进程终止时，操作系统会释放其资源，但是在<code>进程表</code>中关于这个进程的记录还是存在的，直到其父进程调用<code>wait</code>函数。这是因为进程表中存在着子进程的退出状态。</p></blockquote><p>关于子进程还有两个概念：</p><ul><li>僵尸进程(zombie process): 这个概念是由于子进程比父进程的wait函数执行前就结束了造成的。说白了，就是子进程结束了，但是父进程还没有查询子进程的返回状态（<code>wait</code>调用），这时的子进程就处于僵尸状态。</li><li>孤儿进程(orphan process): 这个是由于父进程结束的比子进程还要早（即父进程没有调用<code>wait</code>函数等待子进程）做成的。这种情况Unix/Linux会给他寻找一个父进程，然后等待新的父进程调用wait时结束。这个新的父进程通常是<code>init</code>进程。但是现在Ubuntu发行版中的Linux系统使用的时<code>systemd</code>进程，这个进程会定期调用<code>wait</code>函数。</li></ul><h3 id="进程的切换过程"><a href="#进程的切换过程" class="headerlink" title="进程的切换过程"></a>进程的切换过程</h3><p>这里描述的是关于进程间切换怎样触发（何时），以及操作系统做怎么样的处理（如何操作），关于怎么选择要切换的进程是关于进程调度有关的知识吗，我会在后面总结。</p><p><code>进程控制块</code>保存着一个进程运行时的所有有关数据：程序的代码在内存中的位置，数据的位置，该进程运行时的一些寄存器状态，执行时间等。所以说进程时<code>动态的</code>，它在运行期间会产生一些临时数据。<br>所以当要切换两个进程时，就要把与这个进程相关的所有数据存起来，然后再把新的进程的数据加载到寄存器中，设置PC（CPU的指令指针）等操作。这个过程又叫做<code>上下文切换(context switch)</code>。</p><blockquote><p>官方定义：切换CPU到另一个需要保存当前进程状态和恢复另一个进程的状态，这个任务称为<code>上下文切换(context switch)</code>。 – 《操作系统概念 P78》</p></blockquote><p>何时进行切换：</p><ul><li>时钟中断：这种情况是由于操作系统给每一个程序都设置了<code>最大执行时间</code>（时间片，即程序在被中断前可以执行的最大时间段），即当进程运行时间达到了这个值，就会强制发生中断，中断处理程序就会接管CPU然后调入一个新的进程被执行。</li><li>I/O中断：这种情况是由于进程发生了I/O请求，由于I/O效率过于低下，如果让CPU等待I/O程序完成再继续执行，会浪费很多CPU执行时间，所以为了效率，就设置如果进程发I/O请求，就让他让出CPU，让其他进程先执行，当这个I/O请求执行完成后再等待调度器调度。</li><li>内存失效：这种情况本质也是由于I/O请求引起的，不过这个是由于处理器访问的时一个虚拟内存地址，但是这个虚拟地址单元没有在内存中（缺页中断），操作系统发出一个I/O请求，从外村中把这个下虚拟内存页相关数据加载到内存。这种被暂停的进程被设为<code>阻塞</code>，当想要的块进入内存中后，该进程就会被设置为<code>就绪</code>。</li></ul><p>操作系统如何操作：</p><ul><li>保存CPU上下文环境，包括程序计数器和其他寄存器，这里面存储的都是和该进程执行时有关的数据</li><li>更新当前处于运行态进程的PCB数据，包括进程的状态转变，以及原因，和记账信息</li><li>将进程的PCB放入到响应的队列（进程表），存放的数据结构和具体调度算法相关</li><li>选择另一个进程执行（由调度器选择）</li><li>更新所选的进程的PCB，包括设置其状态为运行态</li><li>更新内存管理的数据结构（MMU的一些值）</li><li>恢复选择的进程在其上一次被执行时的上下文环境，即把上一次的各个寄存器值还原回去，包括PC。</li></ul><h2 id="进程之间通信"><a href="#进程之间通信" class="headerlink" title="进程之间通信"></a>进程之间通信</h2><blockquote><p>这里只说明一下进程之间通信的一些方法和原理，而关于这些方法可能出现的一些问题，怎么解决这些问题暂不讨论。</p></blockquote><p>进程间通信（InterProcess Communication， IPC），肯定至少需要两个进程才可以，这种为其他进程共享数据的进程叫做<code>协作进程</code>。<br>协作进程的好处（多进程一起工作的好处）：</p><ul><li>信息共享：数据被多个进程感兴趣，这样可以减少数据的复制</li><li>计算加速：这种特指可以把一个计算任务分成多个，让多个程序同时计算，然后再有一个总的进程收集的操作。这种要求CPU具有多个核心。</li><li>模块化：这种是为了方便开发和维护，把一个程序分成多个小程序开发或运行，通过小程序之间合作共同完成一个大的任务。</li></ul><p>进程间通信有两种模型：</p><ul><li>共享内存：在内存种建立一种共享区域，让多个进程通过对这个区域读写数据来交换信息。这种方式可能出现<strong>高速缓存一致性问题</strong>。</li><li>消息传递：通过在协作进程间交换消息来实现，在多核CPU上，性能要优于共享内存<blockquote><p>共享内存快于消息传递，这是因为消息传递实现上通常都是需要系统调用，这样会有一部分时间花在内核执行上面，而共享内存的访问可以作为常规访问，无需借助内核。</p></blockquote></li></ul><h3 id="共享内存模型"><a href="#共享内存模型" class="headerlink" title="共享内存模型"></a>共享内存模型</h3><p>采用共享内存的进程间通讯，需要通讯进程建立共享内存区域。这样出现两个问题：</p><ol><li>共享内存区域开辟在哪？</li><li>共享区域怎么共享</li></ol><p>我们先讨论一下第二个问题，每个进程所能访问的内存空间都被操作系统管理，如果进程想要访问不属于它的内存区域，操作系统都会阻止；所以共享内存需要两个或者更多的进程取消这个限制，让别的进程访问自己，然后进程可以访问其他进程开放的共享区域，就可以认为这个共享区域被附加到自己原有的地址空间之后了。怎么实现这个功能呢，在<code>POSIX系统</code>下，是通过<code>内存映射文件</code>的方式将内存空间区域与文件相关联。</p><p><code>POSIX系统</code>内存共享步骤：</p><ol><li>shm_open(): 通过这个系统这个系统调用创建内存共享对象。</li><li>ftruncate(): 用于配置上面返回的共享对象的大小（以字节为单位）</li><li>mmap(): 创建内存映射文件，以便包含共享内存对象。返回一个指向内存映射文件的指针。<br><img src="mm.png" alt="共享内存"></li></ol><p>POSIX系统的代码实例(生产者-消费者模型)：<br>Ubuntu18.04系统下生产者代码：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/mman.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 声明内存空间大小</span>    <span class="token keyword">const</span> <span class="token keyword">int</span> SIZE <span class="token operator">=</span> <span class="token number">4096</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 声明内存空间文件名称</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name <span class="token operator">=</span> <span class="token string">"OS"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 共享数据</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>message_0 <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>message_1 <span class="token operator">=</span> <span class="token string">"World"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 共享内存文件描述符</span>    <span class="token keyword">int</span> shm_fd<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 指向共享内存对象</span>    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建一个共享内存对象</span>    shm_fd <span class="token operator">=</span>  <span class="token function">shm_open</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> O_CREAT <span class="token operator">|</span> O_RDWR<span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 配置共享内存对象的大小</span>    <span class="token function">ftruncate</span><span class="token punctuation">(</span>shm_fd<span class="token punctuation">,</span> SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 实际内存映射到共享内存对象上</span>    ptr <span class="token operator">=</span> <span class="token function">mmap</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//  本质是NULL，使用内核寻找可用的内存空间</span>             SIZE<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 内存空间大小</span>             PROT_WRITE<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 共享空间被保护的模式</span>             MAP_SHARED<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 内存空间对其它进程的可见性</span>             shm_fd<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 共享对象</span>             <span class="token number">0</span> <span class="token comment" spellcheck="true">// 偏移量</span>             <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 写数据</span>    <span class="token function">sprintf</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> <span class="token string">"%s"</span><span class="token punctuation">,</span> message_0<span class="token punctuation">)</span><span class="token punctuation">;</span>    ptr <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>message_0<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sprintf</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> <span class="token string">"%s"</span><span class="token punctuation">,</span> message_1<span class="token punctuation">)</span><span class="token punctuation">;</span>    ptr <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>message_1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Ubuntu18.04系统下消费者代码：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/mman.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 声明内存空间大小</span>    <span class="token keyword">const</span> <span class="token keyword">int</span> SIZE <span class="token operator">=</span> <span class="token number">4096</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 声明内存空间文件名称</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name <span class="token operator">=</span> <span class="token string">"OS"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 共享内存文件描述符</span>    <span class="token keyword">int</span> shm_fd<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 指向共享内存对象</span>    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建一个共享内存对象</span>    shm_fd <span class="token operator">=</span>  <span class="token function">shm_open</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> O_CREAT <span class="token operator">|</span> O_RDONLY<span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 实际内存映射到共享内存对象上</span>    ptr <span class="token operator">=</span> <span class="token function">mmap</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//  本质是NULL，使用内核寻找可用的内存空间</span>             SIZE<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 内存空间大小</span>             PROT_READ<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 共享空间被保护的模式</span>             MAP_SHARED<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 内存空间对其它进程的可见性</span>             shm_fd<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 共享对象</span>             <span class="token number">0</span> <span class="token comment" spellcheck="true">// 偏移量</span>             <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 读数据</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 移除共享对象</span>    <span class="token function">shm_unlink</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译命令：</p><pre class="line-numbers language-shell"><code class="language-shell">$gcc -o consumer consumer.c -lrt$gcc -o producer producer.c -lrt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>注意：必须在编译命令后面加上<code>-lrt</code>，否则报找不到<code>shm_*</code>函数错误。<br><img src="run_result.png" alt="运行结果"></p></blockquote><h3 id="消息传递模型"><a href="#消息传递模型" class="headerlink" title="消息传递模型"></a>消息传递模型</h3><p>这种模型要求存在第三方提供一种通讯机制，比如存在一个消息传递的第三方程序，一个进程往这个消息传递的程序发送，另一个进程从里面读取数据。对于这种第三方程序则要求至少提供两种操作：</p><ul><li>send(message): 发送消息</li><li>receive(message): 接收消息</li></ul><p><img src="queue.png" alt="消息传递"></p><p>按照通信特征可分为：</p><ol><li>直接通信和间接通讯：传递消息时是否有明确的接收人而区分：<code>直接通信</code>，<code>间接通信</code></li><li>同步和异步通讯：进程是否等待消息的<code>接收</code>或<code>到来</code>而区分：<code>阻塞发送</code>，<code>阻塞接收</code>，<code>非阻塞发送</code>，<code>非阻塞接收</code></li><li>自动和显式的缓冲：针对于第三方软件存储消息的消息数量可分为：<code>零容量</code>,<code>有限容量</code>,<code>无线容量</code></li></ol><p>直接通信需要通讯的没有给进程明确的指定通信的接收者或者发送者：</p><ul><li>send(P, message): 向进程P发送message</li><li>receive(Q, message)或者receive(id, message): 从进程Q接受message，或者从任何任何进程获取message，id被设置为与其通讯进程的名称</li></ul><p>间接通信是指进程通过<code>邮箱</code>或者<code>端口</code>来发送和接收消息。</p><ul><li>send(A, message): 向邮箱A发送message</li><li>receive(A, message): 从邮箱A接受message</li></ul><p>使用网络第三发处理消息传递实例：<br>Java实现的网络消息发送者：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 服务端代码</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>BufferedReader<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>InputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>InputStreamReader<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>OutputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>PrintWriter<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>ServerSocket<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>Socket<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServiceProcess</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> InterruptedException <span class="token punctuation">{</span>    ServerSocket serverSocket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerSocket</span><span class="token punctuation">(</span><span class="token number">8888</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Socket socket <span class="token operator">=</span> serverSocket<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    BufferedReader reader <span class="token operator">=</span> <span class="token function">getReader</span><span class="token punctuation">(</span>socket<span class="token punctuation">)</span><span class="token punctuation">;</span>    PrintWriter writer <span class="token operator">=</span> <span class="token function">getWriter</span><span class="token punctuation">(</span>socket<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"服务端接受："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"\t"</span> <span class="token operator">+</span> reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    writer<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"服务端接受完成"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    writer<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    reader<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    writer<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    socket<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    serverSocket<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 封装输出流</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> PrintWriter <span class="token function">getWriter</span><span class="token punctuation">(</span>Socket socket<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    OutputStream outputStream <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span>outputStream<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 封装输入流</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> BufferedReader <span class="token function">getReader</span><span class="token punctuation">(</span>Socket socket<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    InputStream inputStream <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    InputStreamReader inputStreamReader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>inputStream<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span>inputStreamReader<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java使用网络服务接受消息代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 客户端代码</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>BufferedReader<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>InputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>InputStreamReader<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>OutputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>PrintWriter<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>Socket<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClientProcess</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    Socket socket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Socket</span><span class="token punctuation">(</span><span class="token string">"localhost"</span><span class="token punctuation">,</span> <span class="token number">8888</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    BufferedReader reader <span class="token operator">=</span> <span class="token function">getReader</span><span class="token punctuation">(</span>socket<span class="token punctuation">)</span><span class="token punctuation">;</span>    PrintWriter writer <span class="token operator">=</span> <span class="token function">getWriter</span><span class="token punctuation">(</span>socket<span class="token punctuation">)</span><span class="token punctuation">;</span>    writer<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"message：Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    writer<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"客户端接受："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"\t"</span> <span class="token operator">+</span> reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">21312312</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    writer<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    reader<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    socket<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 封装输出流</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> PrintWriter <span class="token function">getWriter</span><span class="token punctuation">(</span>Socket socket<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    OutputStream outputStream <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span>outputStream<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 封装输入流</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> BufferedReader <span class="token function">getReader</span><span class="token punctuation">(</span>Socket socket<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    InputStream inputStream <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    InputStreamReader inputStreamReader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>inputStream<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span>inputStreamReader<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>线程，实际指的是进程中执行的一系列指令序列，是一个进程执行的实际表现；换句话说，线程就是CPU执行的指令集合的抽象，这里不包括进程的设备资源，只针对指令和数据。</p><h3 id="线程和进程之间什么关系"><a href="#线程和进程之间什么关系" class="headerlink" title="线程和进程之间什么关系"></a>线程和进程之间什么关系</h3><p>从进程控制块存储的数据来看，我们可以知道进程的两个特点：</p><ul><li><code>资源所有权</code>: 一个进程包括一个存放进程映像的虚拟地址空间。进程映像是<code>程序</code>，<code>数据</code>， <code>栈</code>和<code>进程块中定义的属性的集合</code>。</li><li><code>调度/执行</code>: 一个进程沿着通过一个或者多个程序的一条执行路径执行。一个进程具有一个执行状态和一个分配的执行级，并且是一个可被操作系统调度和分派的实体。<br>这两个特点是独立的，一个是关于进程资源的特点，一个是关于进程指令执行的特点。在现代操作系统中，为了区分这两个特点，把<code>分派(调度)的单位</code>称为<code>线程</code>或<code>轻量级进程（LWP）</code>；把拥有<code>资源所有权的单位</code>仍称为<code>进程</code>或<code>任务</code>。<blockquote><p>对于操作系统多说，分配资源的单位和被保护的单位为进程。线程是被CPU执行的单位，也即是操作系统调度的单位。</p></blockquote></li></ul><h3 id="什么是多线程？和多进程的区别？"><a href="#什么是多线程？和多进程的区别？" class="headerlink" title="什么是多线程？和多进程的区别？"></a>什么是多线程？和多进程的区别？</h3><p>多道程序设计系统即是多个允许多个进程交替执行，对外可以提供一种多个程序同时执行的感觉，而这些程序之间可以没有关系，或者通过一些其他方式进行通讯，即进程通信。<br>而多线程是指在一个进程内，有多个可同时执行的指令序列。这个进程所拥有的资源，这些指令序列都可以访问，即进程内的资源，对于多线程来说是看见的（共享的），不需要通过其他方式进行通信。</p><blockquote><p>多线程是指操作系统在单个进程内支持多个并发执行路径的能力 — 《操作系统设计与实现精髓 P107》</p></blockquote><p><img src="process.png" alt="多进程交替执行"><br><img src="thread.png" alt="多线程表示"></p><p>其实还有一个特别重要的概念容易混淆：</p><ul><li>并发：表示可以处理多个任务，但是不一定要同时。这种机制更多的是强调有切换执行单元的能力。</li><li>并行：表示可以同时处理多个任务，这种机制表示由多个核心，每一个都可以在同一时刻做一件事情。</li></ul><h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><p>多线程模型是针对什么来说的呢？其针对的是<code>用户线程</code>和<code>内核线程</code>映射之间的关系。<br>上面那就话就说明了线程存在两种方法支持：在用户态下的用户线程（ULT），这种线程的调度由用户程序自身进行管理；另一种是内核态下的内核线程（LT），内核线程由内核进行管理。</p><h4 id="多对一"><a href="#多对一" class="headerlink" title="多对一"></a>多对一</h4><p>多对一是指<code>多个用户线程</code>对应到一个<code>内核线程</code>上，从内核上看，本质就是内核执行一个单进程程序，按照PC指针进行执行指令，无法感知上层是无法处理指令切换等操作。这种对线程的管理是由应用程序自身管理的（或者使用线程库管理）。<br><img src="more2one.png" alt="多对一"></p><p>优点：</p><ul><li>由用户管理线程，效率更高</li></ul><p>缺点：</p><ul><li>这样的系统就是指操作系统只能对外提供一个线程，对现在多核CPU不适用</li><li>如果用户程序在内核级线程阻塞时，当导致该进程其他线程也无法执行</li></ul><h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><p>一对一模型是指<code>一个</code>用户线程对应到<code>一个</code>内核线程。该模型可以解决一个线程阻塞时，不影响其他线程执行。<br>但是也存在一个缺点：当用户线程过多时，内核创建内核线程会使用大量性能。<br><img src="one2one.png" alt="一对一"></p><h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><p>多对多模型多路复用多个用户线程到相同数量或者更少数量的内核线程。<br><img src="more2more.png" alt="多对多"></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li>线程状态和具体系统具体实现或者线程库的实现方式有关。这里不再叙述。</li><li>关于PCB具体存储的数据可以查看Linux下<code>linux/sched.h</code>文件下的<code>task_struct</code>结构体。</li><li>未叙述的消息通信的具体实现方式有：套接字，远程过程调用，管道</li><li>线程实现可以查看<code>Pthreads</code>库，windows线程，Linux使用<code>fork</code>和<code>exec</code>创建线程。</li><li>关于线程创建和销毁，以及调度程序的实现未叙述</li><li>为了减少线程创建的性能消耗，可以使用<code>线程池</code>以及其他方法未叙述。</li><li>对称多处理（SMP）体系结构及关于线程未叙述，可参考《操作系统精髓与设计原理》一书第4章</li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang环境安装</title>
      <link href="/2019/11/22/go-install/"/>
      <url>/2019/11/22/go-install/</url>
      
        <content type="html"><![CDATA[<h2 id="Golang语言介绍"><a href="#Golang语言介绍" class="headerlink" title="Golang语言介绍"></a>Golang语言介绍</h2><p>Golang语言是Google公司开发的一种类C语言，是一门编译型的静态语言，而且Golang语言天生带有高并发功能的语言级别支持。<br>Golang语言类C并不是仅仅在语法上和C语言类似，而且好包含了C的指针特性（优点），可能你有C语言基础的，一看到指针就感觉到可怕，但是Golang的指针只具有C指针的优点，花样也没有C语言多，所以没那么可怕。<br>忘了告诉你了，Golang的语言设计者其中一位就是C语言和Unix系统开发者<code>Ken Thompson</code>大佬。Golang被称为当代的C语言，当然要有现在其他语言所拥有的语言特性：高并发（协程），垃圾回收GC，类型推断和闭包等。<br>当前比较流行的Docker容器技术就是使用Go语言开发的，区块链技术实现也可以使用Go语言。Go有这么多优点，还不学吗？</p><h2 id="Golang语言环境安装"><a href="#Golang语言环境安装" class="headerlink" title="Golang语言环境安装"></a>Golang语言环境安装</h2><h3 id="1-Golang环境下载"><a href="#1-Golang环境下载" class="headerlink" title="1. Golang环境下载"></a>1. Golang环境下载</h3><p>第一步肯定是下载Golang的安装包啦！但是，由于某些原因，我们是无法访问Google服务器，但是国内有一些大佬已经在国内做了代理，可以通过国内代理下载：</p><ul><li><p>国内Golang下载：<code>https://studygolang.com/dl</code></p></li><li><p>官方Golang下载：<code>https://golang.org/dl/</code></p><p>  点击网址，我们可以看到一些下载选项：<br>  <img src="download1.png" alt="国内下载"></p></li></ul><p>我们根据自己电脑的操作系统选择不同的下载包下载即可。不过可以看到windows和MacOS 都支持两种下载方式，一种是<code>zip</code>包方式下载，另一种就是推荐下载中列出的<code>msi</code>/<code>pkg</code>。二者差别是：<code>zip</code>下载后需要解压然后自己设置一些变量，<code>msi</code>和<code>pkg</code>都是可执行文件，直接点击就可以。我喜欢使用<code>zip</code>方式，因为我认为这种更新更方便，毕竟什么都是自己在配置。</p><blockquote><p>Golang自从1.5版本之后就是自举实现，如果你想自己编译，则需要下载<code>推荐下载</code>中的源码，并且你自己的电脑上也要有Go环境。</p></blockquote><h3 id="2-Golang安装"><a href="#2-Golang安装" class="headerlink" title="2. Golang安装"></a>2. Golang安装</h3><p>点击下载完之后（我下载的是zip文件），然后解压，我把解压后的文件夹go，移动到<code>D盘根目录上</code>。如果你是使用的<code>msi</code>方式，直接双击运行即可，需要注意它的安装位置（在点击next的时候你也可以改变）。</p><h3 id="3-设置PATH变量"><a href="#3-设置PATH变量" class="headerlink" title="3. 设置PATH变量"></a>3. 设置<code>PATH</code>变量</h3><p>   <code>PATH</code>是一个系统原本就带有变量，它的作用是当你执行一个命令或程序的时候，系统可以检查这个变量中的路径，查找那个程序，这样就不用在程序的安装目录里才能执行程序，这个变量每一个系统都有，Windows和Linux的区别是Windows使用英文的<code>;</code>作为多个路径分割符，而Linux使用英文<code>:</code>作为系统分割符。我们设置这个变量就是把我们的Go程序安装目录下的<code>bin\go.exe</code>和<code>bin\fmt.exe</code>程序可以让系统找到，所以，我们要给<code>APTH</code>环境变量添加一个<code>;GO_INSTALL_PATH\bin</code>。其中<code>GO_INSTALL_PATH</code>就是Go安装的路径。</p><blockquote><p>注意：windows下路径分割符是<code>\</code>,Linux下是<code>/</code></p></blockquote><h3 id="4-设置GOROOT，GOPATH，GOBIN环境变量"><a href="#4-设置GOROOT，GOPATH，GOBIN环境变量" class="headerlink" title="4. 设置GOROOT，GOPATH，GOBIN环境变量"></a>4. 设置<code>GOROOT</code>，<code>GOPATH</code>，<code>GOBIN</code>环境变量</h3><ul><li><code>GOROOT</code>：这个环境变量类似于Java的<code>JAVA_HOME</code>，作用就是告诉系统或者其他需要知道Go的安装位置的一个系统变量</li><li><code>GOPATH</code>：设置变量就是指定你的工作区（文件夹），简单一句话，你要在那个文件夹下写项目。因为开发程序需要依赖一些其他的包（库/别人写的代码），所以你要先下载下来，下载到那个地方，就是这个变量所指的文件夹下。这个文件夹下也有一些结构：<ul><li>bin文件夹：这个文件夹就是存放go编译后可以执行的一些程序</li><li>pkg文件夹：这个文件夹存放的是下载下来的官方的代码或者别人的代码<code>编译后的库</code>。什么叫做库，类似与压缩包，不过这个压缩包是以<code>.a</code>结尾的。</li><li>src文件夹：这个文件夹存放的是下载下来的官方的代码或者别人的代码，我们自己写的代码也是在这个里面。如果不想在一个文件夹里面写程序，可以设置多个<code>GOPATH</code>，或者使用Go1.11版本之后开始支持的模块，这个以后再说吧。</li></ul></li><li><code>GOBIN</code>：这个变量可以不用设置，如果设置好<code>GOPATH</code>的话。这个变量是设置Go下载下来的程序<code>编译成可执行程序后的位置</code>。这个和<code>GOPATH/pkg</code>的区别就是: <code>GOBIN</code>是go可以下载别人的代码，然后编译成可以执行的程序，然后执行，这个等一会就看到，而<code>GOPATH/pkg</code>则是我们写的代码需要引用别人的代码（在<code>GOPATH/src</code>中），我们总不能把别人的代码编译成程序然后在自己的代码中调用吧，所以需要把别人的代码编程一种库的形式使用，类似与Java中的<code>jar</code>文件（其实jar文件就是一个压缩文件）。</li></ul><p>说了这么多，也要开始设置动手设置一下吧：</p><p>右击<code>此电脑</code> -&gt; 点击<code>属性</code> -&gt; 点击左侧的<code>系统高级设置</code> -&gt; 点击弹出框中的<code>环境变量</code>,然后看图吧：<br><img src="1.png" alt="步骤一"></p><p><img src="2.png" alt="步骤二"></p><p><img src="3.png" alt="步骤三"> </p><blockquote><p>设置上面的三个变量。</p></blockquote><p><img src="4.png" alt="给go添加到PATH上"></p><h3 id="5-检查一下吧！看看可不可以得到Go的一些信息："><a href="#5-检查一下吧！看看可不可以得到Go的一些信息：" class="headerlink" title="5. 检查一下吧！看看可不可以得到Go的一些信息："></a>5. 检查一下吧！看看可不可以得到Go的一些信息：</h3><p>   打开一个操作系统的终端，然后输入<code>go version</code>和<code>go env</code>看看你都可以看到什么。</p><h2 id="选择一个开发工具"><a href="#选择一个开发工具" class="headerlink" title="选择一个开发工具"></a>选择一个开发工具</h2><p>推荐工具</p><ul><li>LiteIDE（没用过）</li><li>GoLand（收费，装了，不经常使用）</li><li>VsCode（挺好的，我习惯使用的）</li></ul><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>如果你使用vscode开发的话，你需要安装Go插件，当你使用vscode打开第一个go文件时，会提醒你是否安装一些go的工具，如果你点击确定，含有可能下了半天还没有下载下来，这是因为vscode支持的go的一些工具是google服务器上的，所以肯有可能下载失败。百度你也可以搜，有很多教程，但是最好的解决方式就是设置一个代理。可以是你所理解的代理，也可以是其他大佬给我们提供的代理。<br>我这里推荐使用：<a href="https://goproxy.io/" target="_blank" rel="noopener">https://goproxy.io/</a><br>访问这个网址，里面有教程。或者我直接告诉你：就是再设置一个环境变量<code>GOPROXY</code>,值就是:<code>https://goproxy.io</code>，设置方法你应该会了。设置完成后，你可以再次运行<code>go env</code>命令，找找输出列表中<code>GOPROXY</code>的值是不是设置的那个，然后你再试试是否可以下载。</p><h2 id="Hello-world-for-go"><a href="#Hello-world-for-go" class="headerlink" title="Hello world for go"></a>Hello world for go</h2><p>在<code>GOPATH/src</code>新建一个文件夹，然后在新建一个名为hello.go的文件<br>内容：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello world for go!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后打开终端，执行<code>go run hello.go</code>试试看！<br><img src="run.png" alt="运行结果"></p><h2 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h2><p>Go和开源有着很重要的关系，以后就会知道！</p><p>在GitHub上有两本Go开源书籍：</p><ul><li><a href="https://github.com/golang101/golang101" target="_blank" rel="noopener">https://github.com/golang101/golang101</a></li><li><a href="https://github.com/chai2010/advanced-go-programming-book" target="_blank" rel="noopener">https://github.com/chai2010/advanced-go-programming-book</a><blockquote><p>这两本书讲的比较深</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>终于要开始写博客</title>
      <link href="/2019/11/22/2019-start/"/>
      <url>/2019/11/22/2019-start/</url>
      
        <content type="html"><![CDATA[<p>为什么说我是“终于”要开始写博客了呢？因为对于博客，我努力尝试过很多次最终的结果：现在开始写博客。这其中每次都是因为不同的想法。</p><p>第一次想写博客是因为我从大一学会Java Web后自己想做一个博客系统然后在上面写，可惜自己前端知识特别差，那当时看到CSS就头痛，更没用过相关的框架，努力了一些Bootstrap框架后就放弃了，然后使用了有道云笔记。<br>第二次想写博客是因为在一个群里，群主要举办一个活动，然后想参加互动必须要准备一个博客，我就草草的准备了一个。之后想再上面写点东西，发现自己不知道写什么，也不知道自己有什么可以写的。不久之后也就忘了。<br>之后也有很多次想过，想的时候感觉自己可以做好，但是总以失败告终；比如想在掘金上写一点东西，自己开始写的时候，总是发现自己以为懂的东西，给别人将却讲不出来……</p><p>为什么今天我又开始，这次会不会又再次放弃呢？说实话，我也不知道，只是最近读了一些书，回想了过去大学三年，想了想这三年我学过的知识，用过的技术，才发现我什么都没有留下了，能做的不过是接别人的话，顺势装个x。所以，我现在开始想写博客原因有三个，其一：我要现在开始准备为我的毕业做“总复习”，把以后找工作的知识点，以前用过的技术，总体上复习一下，对使用的技术及其原理都要做一些了解，所以我要找个地方记录，没有选择使用笔记的方式而选择客是因为，我想把我所理解的知识分享出去，如果错误也希望有人可以反馈给我，不知等我用的到时候才发现；其二：我大一暑假，我当时注意到Go语言，并且开始找了一些视频学习，之后就是找了一些书看看，总体掌握的很差。也是最近几天，登录管看到biezhi大佬的<code>代码真香</code>频道，发现他的Go语言视频已经有一年没有更新过了，我就有了一个打算：边学习边录制视频交给别人。叫别人一个简单的知识点容易，但是要教一套语言使别人可以入门，要有很多课程设计，知识规划和总结，所以就想写博客，一作为自己对Go知识点的梳理，二作为Go视频中知识点的补充。这两个原因算是我开始写博客的主要原因。如果要多说一个原因，那就是，如你所见，我的文笔并不好，我也想借机练习一下。</p><p>2019也快结束了，我也快要开始找工作了，只希望接下来的几个月可以好好学习知识，充实自己，做好计划的每一件事。2019亦结束，亦开始！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
